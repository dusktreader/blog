{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Posts","text":"<p>Tech learnings and musings from the.dusktreader.</p> <p>Open to work</p> <p>I'm looking for a job right now! If you know of any openings that match my skill-set, please let me know! You can read my resume over at my cv site. Thanks!</p> <p>the.dusktreader blog \u00a9 2025 by Tucker Beck is licensed under CC BY-SA 4.0</p>"},{"location":"2025/03/29/self-contained-python-scripts-with-uv/","title":"Self-contained Python scripts with <code>uv</code>","text":"<p>TLDR</p> <p>You can add uv into the shebang line for a Python script to make it a self-contained executable.</p> <p>I am working on a Go project to better learn the language. It's a simple API backed by a postgres database.</p> <p>When I need to test out an endpoint, I prefer to use the httpx python package inside an ipython REPL over making curl requests. It's nice to be able to introspect responses and easily package payloads with dicts instead of writing out JSON.</p> <p>Anyway, I decided to write a script to upsert some user data so that I can beat on my <code>/users</code> endpoint.</p> <p>My <code>jam_users.py</code> script looks like this:</p> <pre><code>import httpx\nimport IPython\nfrom loguru import logger\n\nusers = [\n    dict(name=\"The Dude\", email=\"the.dude@abides.com\", password=\"thedudeabides\"),\n    dict(name=\"Walter Sobchak\", email=\"walter@sobchak-security.com\", password=\"vietnamvet\"),\n    dict(name=\"Donnie\", email=\"donniesurfs@yahoo.com\", password=\"iamthewalrus\"),\n    dict(name=\"Maude\", email=\"mauddie@avant-guard.com\", password=\"goodmanandthorough\"),\n]\n\nr = httpx.get(\"http://localhost:4000/v1/users\")\nr.raise_for_status()\n\nfor user in r.json()[\"users\"]:\n    logger.info(f\"Deleting: {user['name']}\")\n    r = httpx.delete(f\"http://localhost:4000/v1/users/{user['id']}\")\n    r.raise_for_status()\n\nfor user in users:\n    r = httpx.post(\"http://localhost:4000/v1/users\", json=user)\n    r.raise_for_status()\n    logger.info(f\"Created: {r.json()}\")\n\nIPython.embed()\n</code></pre> <p>This is really straight-forward. It will clear out any existing users and then insert these test users. Right after that, I get dropped into an <code>ipython</code> repl to do what I need for testing. All I have to do is run:</p> <pre><code>python jam_users.py\n</code></pre> <p>However, if I want to run the script as-is, I will need to choose one of these approaches:</p> <ul> <li>Install the dependencies <code>httpx</code>, <code>IPython</code>, and <code>loguru</code> globally in my system python</li> <li>Create a virtual environment, activate it, install deps, and run my script while the venv is activated</li> </ul> <p>These are both not great options in my opinion. These approaches also rely on having a system python installed that is compatible with these packages. This isn't as big of a problem, but something to consider anyway.</p> <p>I've been using uv a lot lately, and I'm becoming quite enamoured with its usefulness as a package manager, efficiency as a pip replacement, and abilities for isolated python executables. One thing that I haven't used much yet are the special <code># /// script</code> tags in a python script.</p> <p>When I first read about this functionality, I was pretty skeptical. I'm not particularly keen on embedding syntax into comments. However, this seemed like the perfect application. So, updated my script to include the deps in the script header like so:</p> <pre><code># /// script\n# dependencies = [\"ipython\", \"httpx\", \"loguru\"]\n# ///\nimport httpx\nimport IPython\nfrom loguru import logger\n\n...\n</code></pre> <p>With this added, now I can run the script really easily with <code>uv</code>:</p> <pre><code>uv run jam_users.py\n</code></pre> <p>Great! Now, <code>uv</code> will create an isolated virtual environment for the script, download the dependencies and install them, and then run my script in the context of that venv! I don't have to manage the virtual environment myself nor worry about cluttering my system python with packages that I will invariably forget to remove later.</p> <p>One nice thing about a regular Python script, though, is that you can make it executable with a shebang line:</p> <pre><code>#!/usr/bin/env python\n...\n</code></pre> <p>Now, if I make the script executable (<code>chmod +x jam_users.py</code>), I can invoke it directly as an executable script! However, this won't take advantage of the <code>uv</code> script header because Python itself will just ignore the comment.</p> <p>So, I did some digging and found out that you can actually embed the invocation of the uv command right in the shebang line like so:</p> <pre><code>#!/usr/bin/env -S uv run --script\n# /// script\n# dependencies = [\"ipython\", \"httpx\", \"loguru\"]\n# ///\nimport httpx\nimport IPython\nfrom loguru import logger\n\n...\n</code></pre> <p>This works because the <code>-S</code> flag tells the system to split everything after it into separate arguments before passing it to the system's <code>env</code>.</p> <p>Now (after <code>chmod +x jam_users.py</code>, of course), I can execute my script directly:</p> <pre><code>./jam_users.py\n</code></pre> <p>That's it! What's even better is that I can run this script on any (Unix) system that has <code>uv</code> installed without needing to do ANY dependency or virtual environment management.</p> <p>Now, this script itself is really trivial and not much more than a toy example. However, in my past I have written rather complex scripts that I needed to hand off to other users to run. Of course, this always came with a long explanation of how to prepare their system just to run the script. This approach solves that problem instantly and painlessly (as long as they have <code>uv</code> installed).</p> <p>Take it for a spin, and let me know your thoughts.</p> <p>Thanks for reading!</p>","tags":["Python","uv"]},{"location":"archive/2025/","title":"2025","text":""},{"location":"category/dev/","title":"dev","text":""}]}