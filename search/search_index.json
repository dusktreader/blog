{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Posts","text":"<p>Tech learnings and musings from the.dusktreader.</p> <p>Open to work</p> <p>I'm looking for a job right now! If you know of any openings that match my skill-set, please let me know! You can read my resume over at my cv site. Thanks!</p> <p>the.dusktreader blog \u00a9 2025 by Tucker Beck is licensed under CC BY-SA 4.0</p>"},{"location":"2025/03/29/self-contained-python-scripts-with-uv/","title":"Self-contained Python scripts with <code>uv</code>","text":"<p>TLDR</p> <p>You can add uv into the shebang line for a Python script to make it a self-contained executable.</p> <p>I am working on a Go project to better learn the language. It's a simple API backed by a postgres database.</p> <p>When I need to test out an endpoint, I prefer to use the httpx python package inside an ipython REPL over making curl requests. It's nice to be able to introspect responses and easily package payloads with dicts instead of writing out JSON.</p> <p>Anyway, I decided to write a script to upsert some user data so that I can beat on my <code>/users</code> endpoint.</p> <p>My <code>jam_users.py</code> script looks like this:</p> <pre><code>import httpx\nimport IPython\nfrom loguru import logger\n\nusers = [\n    dict(name=\"The Dude\", email=\"the.dude@abides.com\", password=\"thedudeabides\"),\n    dict(name=\"Walter Sobchak\", email=\"walter@sobchak-security.com\", password=\"vietnamvet\"),\n    dict(name=\"Donnie\", email=\"donniesurfs@yahoo.com\", password=\"iamthewalrus\"),\n    dict(name=\"Maude\", email=\"mauddie@avant-guard.com\", password=\"goodmanandthorough\"),\n]\n\nr = httpx.get(\"http://localhost:4000/v1/users\")\nr.raise_for_status()\n\nfor user in r.json()[\"users\"]:\n    logger.info(f\"Deleting: {user['name']}\")\n    r = httpx.delete(f\"http://localhost:4000/v1/users/{user['id']}\")\n    r.raise_for_status()\n\nfor user in users:\n    r = httpx.post(\"http://localhost:4000/v1/users\", json=user)\n    r.raise_for_status()\n    logger.info(f\"Created: {r.json()}\")\n\nIPython.embed()\n</code></pre> <p>This is really straight-forward. It will clear out any existing users and then insert these test users. Right after that, I get dropped into an <code>ipython</code> repl to do what I need for testing. All I have to do is run:</p> <pre><code>python jam_users.py\n</code></pre> <p>However, if I want to run the script as-is, I will need to choose one of these approaches:</p> <ul> <li>Install the dependencies <code>httpx</code>, <code>IPython</code>, and <code>loguru</code> globally in my system python</li> <li>Create a virtual environment, activate it, install deps, and run my script while the venv is activated</li> </ul> <p>These are both not great options in my opinion. These approaches also rely on having a system python installed that is compatible with these packages. This isn't as big of a problem, but something to consider anyway.</p> <p>I've been using uv a lot lately, and I'm becoming quite enamoured with its usefulness as a package manager, efficiency as a pip replacement, and abilities for isolated python executables. One thing that I haven't used much yet are the special <code># /// script</code> tags in a python script.</p> <p>When I first read about this functionality, I was pretty skeptical. I'm not particularly keen on embedding syntax into comments. However, this seemed like the perfect application. So, updated my script to include the deps in the script header like so:</p> <pre><code># /// script\n# dependencies = [\"ipython\", \"httpx\", \"loguru\"]\n# ///\nimport httpx\nimport IPython\nfrom loguru import logger\n\n...\n</code></pre> <p>With this added, now I can run the script really easily with <code>uv</code>:</p> <pre><code>uv run jam_users.py\n</code></pre> <p>Great! Now, <code>uv</code> will create an isolated virtual environment for the script, download the dependencies and install them, and then run my script in the context of that venv! I don't have to manage the virtual environment myself nor worry about cluttering my system python with packages that I will invariably forget to remove later.</p> <p>One nice thing about a regular Python script, though, is that you can make it executable with a shebang line:</p> <pre><code>#!/usr/bin/env python\n...\n</code></pre> <p>Now, if I make the script executable (<code>chmod +x jam_users.py</code>), I can invoke it directly as an executable script! However, this won't take advantage of the <code>uv</code> script header because Python itself will just ignore the comment.</p> <p>So, I did some digging and found out that you can actually embed the invocation of the uv command right in the shebang line like so:</p> <pre><code>#!/usr/bin/env -S uv run --script\n# /// script\n# dependencies = [\"ipython\", \"httpx\", \"loguru\"]\n# ///\nimport httpx\nimport IPython\nfrom loguru import logger\n\n...\n</code></pre> <p>This works because the <code>-S</code> flag tells the system to split everything after it into separate arguments before passing it to the system's <code>env</code>.</p> <p>Now (after <code>chmod +x jam_users.py</code>, of course), I can execute my script directly:</p> <pre><code>./jam_users.py\n</code></pre> <p>That's it! What's even better is that I can run this script on any (Unix) system that has <code>uv</code> installed without needing to do ANY dependency or virtual environment management.</p> <p>Now, this script itself is really trivial and not much more than a toy example. However, in my past I have written rather complex scripts that I needed to hand off to other users to run. Of course, this always came with a long explanation of how to prepare their system just to run the script. This approach solves that problem instantly and painlessly (as long as they have <code>uv</code> installed).</p> <p>Take it for a spin, and let me know your thoughts.</p> <p>Thanks for reading!</p>","tags":["Python","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/","title":"Bootstrapping Python projects with <code>copier</code>","text":"<p>TLDR</p> <p>I used <code>copier</code> to create a python project template that includes logic to deploy the project to GitHub.</p> <p>I tend to create a lot of Python projects of various sizes. In the past few weeks, this has been even more frequent. Just a few days ago, I started a new project called drivel. It is a CLI and Python package that generates fun metasyntactic names (think <code>foo</code>, <code>bar</code>, <code>baz</code>) to use in my code. You can read more about it in the drivel docs if you want to learn more.</p> <p>When I went to start this project, I did what I usually do. I copied one of my other projects to a new directory and started ripping stuff out, renaming things, and just generally futzing around until I had the scaffolding for my new project. This isn't hard work, but it always ends up taking a lot longer than I expect.</p> <p>There are a lot of conventions that I've gotten attached to in my projects over the years. And, while it's not that hard to just borrow things from past projects, it's boring work that cries out to be automated.</p> <p>So, I decided to create a project template that would allow me to do all this in just a matter of seconds.</p> <p>Open to work</p> <p>I'm looking for a job right now! If you know of any openings that match my skill-set, please let me know! You can read my resume over at my cv site. Thanks!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#a-case-study","title":"A case study","text":"<p>As I go through this article, I'm going to use an imaginary project as a case study. I'm calling it <code>space-monkey</code>, because it's all about doing an exploratory trial run. Just like the monkeys and apes that were sent into orbit before humans, this project will be used to explore and test my project template.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#the-boring-stuff","title":"The boring stuff","text":"<p>Before I get into how I actually built out the template, I want to take some time going over the reasons why the projects I produce from this template are the way they are. To do that, I need to go over my personal philosophy for setting up Python projects. This might not be that interesting to you. If so, feel free to skip ahead to the fun stuff.</p> <p>There are some basic essentials that I like to have in my Python projects. These come in three flavors:</p> <ol> <li>Baseline requirements for a good project</li> <li>Ergonomics to make the project nice to work on</li> <li>Processes to make the project ready to go</li> </ol> <p>Let's look at each one in a little detail.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#baseline-requirements","title":"Baseline requirements","text":"<p>I am kind of a stickler for a few baseline requirements that I have for my projects. Even for small projects, I like to make sure that requirements are met so I don't feel...icky working in my own code.</p> <p>Here are the requirements that I've settled on over the years of writing Python projects:</p> <ul> <li>A decent <code>README.md</code></li> <li>A <code>LICENSE.md</code> file</li> <li>A <code>CHANGELOG.md</code></li> <li>A <code>pyproject.toml</code></li> <li>Good project structure</li> <li>Docs</li> </ul> <p>Each one of these requirements is born of past experiences working on Python projects. Along the way, I've learned some best practices and definitely developed some rather opinionated preferences for each. As I walk through these, please keep in mind that these are my opinions and preferences for my own projects. I don't think it's gospel; it's just what I like.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#readmemd","title":"<code>README.md</code>","text":"<p>I've become convinced  that Markdown is the best format for writing documentation at every level. I used to be pretty attached to reStructuredText (or RST), and it is a very powerful spec for writing technical documentation. But it has some serious drawbacks. For one, the syntax is far more esoteric. Also, working with the Sphinx documentation engine is not very fun. Overall, Markdown is just better. It doesn't come out-of-the-box with all the powerful features available with Sphinx and reStructuredText, but I've found that using Markdown with the extensions provided by mkdocs-material provides what I need and makes producing nice looking documentation a breeze.</p> <p>So, I usually start with a <code>README.md</code> with a few essential elements:</p> <ul> <li>A project summary</li> <li>A \"Super-quick start\" section that briefly explains how to install the project.</li> <li>For a CLI or similar tool, a brief demonstration of how to run it</li> <li>A link to the documentation page</li> </ul> <p>That's pretty much it. For smaller projects, I've leaned on the README to document the whole project. However, with mkdocs-material and GitHub Pages, it's so easy to stand up a docs site that I usually do that for even small projects.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#licensemd","title":"<code>LICENSE.md</code>","text":"<p>For any project that you are going to host on a public GitHub repository, you need to have a software license. The GitHub docs offer a good explanation:</p> <p>without a license, the default copyright laws apply, meaning that you retain all rights to your source code and no one may reproduce, distribute, or create derivative works from your work.</p> <p>Another good reason to have a license is to make sure that you can't be held liable for misuse of your software or its failure in any situation.</p> <p>As a rule, I prefer a very permissive license and use the MIT License</p> <p>But, why make it a Markdown file and not not just <code>LICENSE</code> without an extension? Well, I usually use just a little bit of markup in the file. More importantly, though, it signals to the OS and users that the file contains text and should be opened with a text viewer/editor.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#changelogmd","title":"<code>CHANGELOG.md</code>","text":"<p>I used to be pretty lax with CHANGELOGs, but after reading keep a changelog, I realized that it's a pretty important element of an open-source software project.</p> <p>Since I started including them, I've found that they are extremely useful for other people who want to learn about how your project has evolved over time. More importantly, it helps identify when significant changes (like dropping version support) came to be. Now, when I'm reading up on a project without a changelog, I get pretty grumpy.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#structure","title":"Structure","text":"<p>This is so subjective. I've also been through many iterations of different structures with pretty strong opinions on each one that I adopted. I used to be pretty adamant about using a \"flat layout\", but these days I've adopted the src layout. In the end, the deciding factor was that uv prefers the \"src layout\", and I've been using <code>uv</code> a lot lately.</p> <p>So, my basic project structure looks like:</p> <pre><code>space-monkey/\n\u2514\u2500\u2500 .github/\n    \u251c\u2500\u2500 workflows/\n    \u2502   \u251c\u2500\u2500 deploy.yml\n    \u2502   \u251c\u2500\u2500 docs.yml\n    \u2502   \u2514\u2500\u2500 main.yml\n    \u251c\u2500\u2500 docs/\n    \u2502   \u251c\u2500\u2500 source/\n    \u2502   \u2502   \u251c\u2500\u2500 features.md\n    \u2502   \u2502   \u251c\u2500\u2500 index.md\n    \u2502   \u2502   \u251c\u2500\u2500 quickstart.md\n    \u2502   \u2502   \u2514\u2500\u2500 reference.md\n    \u2502   \u2514\u2500\u2500 mkdocs.yaml\n    \u251c\u2500\u2500 src/\n    \u2502   \u2514\u2500\u2500 space_monkey/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 main.py\n    \u2502       \u2514\u2500\u2500 py.typed\n    \u2514\u2500\u2500 tests/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u2514\u2500\u2500 test_main.py\n</code></pre> <p>Note that this structure includes a <code>tests</code> directory that includes a full suite of unit tests and integration tests when they are appropriate. I use pytest to run my tests--it's really just the best option out there.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#documentation","title":"Documentation","text":"<p>As I mentioned in the README.md section, I usually put the bulk of my documentation in a static site hosted on GitHub pages and generated by mkdocs-material. It's really easy, and it results in a nice docs site that is searchable, themed, and familiar.</p> <p>In fact, this blog itself is a GitHub Pages site built with mkdocs-material!</p> <p>At a minimum, I like my docs to include an overview of the project, a good description of usage, a full explanation of the features, examples, and a reference section that is built from the docstrings in the project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#ergonomics","title":"Ergonomics","text":"<p>Beyond the baseline requirements, I like to add some elements to my projects that make them nice to work on. I love good tools that are pleasure to use, so I'm always looking for cool things I can bring into my projects to make them more fun to work on. There are 3 core elements to all my projects that improve the ergonomics. These include:</p> <ol> <li>A <code>Makefile</code></li> <li><code>uv</code> support</li> <li>GitHub actions</li> </ol> <p>I'll explain a little about each one.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#makefile","title":"<code>Makefile</code>","text":"<p>There are a lot of alternatives to <code>make</code> these days. So, why do I chose something so old? It certainly isn't the syntax. Instead, it's because <code>make</code> comes pre-installed in most unix systems. So, it's nice to use something that doesn't require an installation. That might not be a great reason, but I have a good <code>Makefile</code> structure now, so I'm sticking with it for the time being.</p> <p>My <code>Makefile</code> usually has these targets:</p> <ul> <li>test:       run the test suite</li> <li>lint:       run code linters</li> <li>types:      run type-checkers</li> <li>qa:         run all three of <code>test</code>, <code>lint</code>, and <code>types</code></li> <li>format:     run a code formatter</li> <li>docs:       build the docs</li> <li>docs-serve: build the docs and run them in a local, auto-refreshing server</li> <li>clean:      clean up all the cruft including cache files and build artifacts</li> <li>help:       show available <code>make</code> targets</li> </ul> <p>It's really convenient to just run <code>make qa</code> and see all the quality checks being applied.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#uv","title":"<code>uv</code>","text":"<p>Like I said before, I've been using <code>uv</code> these days for all my new projects. It's really fast and has most of the features I want in project management software for Python. Beyond that, though, it has massive adoption in the Python community. I really believe this will become the standard for Python projects in the coming years.</p> <p>I used to be a die-hard supporter of <code>poetry</code>. I still like the project, but I've found that <code>uv</code> is just nicer to use.</p> <p>As a bonus, <code>uv</code> comes with built-in Python version management with a better API and faster execution times than pyenv (which I used to use).</p> <p>So, all my projects these days are configured for <code>uv</code> to manage them. Since <code>uv</code> doesn't have a build backend yet, I fallback on using hatchling in my <code>pyproject.toml</code></p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#github-actions","title":"GitHub Actions","text":"<p>It's really nice to take advantage of CI even in small projects. Having automated quality checks and deployments built right into a project really take it to the next level. I usually set up three GitHub actions for my projects:</p> <ul> <li>run qa checks on any pushed branch</li> <li>build &amp; deploy docs on any merge to <code>main</code></li> <li>deploy a new version of the package on any tag matching a semver format</li> </ul> <p>Many of the projects I make end up getting deployed on PyPI, so the third of these actions is really nice to have. If the project won't be deployed as a package, I'll leave off the third one.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#processes","title":"Processes","text":"<p>This might be the most boring of these boring parts. In general, when I'm starting a new project, I like to put it up on GitHub right away. This allows me to work on the project from anywhere. Since I work from a rented office a few miles down the road, it's nice to be able to just pull down the latest changes from GitHub directly instead of using <code>scp</code> or <code>rsync</code> to move the files around. So, to get a new project set up on GitHub, I do these steps:</p> <ol> <li>Initialize the git repo</li> <li>Host it on GitHub</li> <li>Set up a GitHub Page</li> </ol> <p>None of these are interesting, but they are important steps, and (before the new project template) they were all done manually.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#git-init","title":"<code>git init</code>","text":"<p>That's the main command at the heart of setting up a new git repo locally. However, there's a few other things I like to do. I like my first commit to have nothing in it but a <code>README.md</code> that contains nothing but the title of the project. It's not really a fun thing to try to rebase the first commit in a git repo. So, having it be almost completely empty means that I can use it as an immutable base for all future commits.</p> <pre><code>git init\ngit add REAME.md\ngit commit -m \"Initial Commit\"\n</code></pre> <p>Once that's done, my next commit will contain all of the contents (minus cruft that <code>make clean</code> will remove) of the project. Usually, I won't finalize this commit until I have the MVP working. That often means making several temporary commits that all get squashed down into this one before I push it anywhere.</p> <pre><code>git add .\ngit commit -m \"feat: Bootstrapped the space-mokey project\"\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#to-github","title":"To GitHub","text":"<p>This is just a matter of going to GitHub and clicking the <code>+</code> button to create a new repository:</p> <p></p> <p>Screenshot of the plus button</p> <p>Then, there's the fun of setting the upstream git repository hosted on GitHub as the origin for the local git repository. Once that's done, it's just a matter of pushing <code>main</code> to origin.</p> <pre><code>git remote add origin git@github.com:dusktreader/space-monkey.git\ngit push origin main\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#github-pages","title":"GitHub Pages","text":"<p>Finally, to publish the docs on GitHub pages, you have to change a few settings. First, you need to go to the <code>settings</code> for your project and find the <code>actions</code> section on the left. Once there, scroll down and find \"Workflow Permissions\". Then, change it to enable \"Read and write permissions\".</p> <p></p> <p>Screenshot of actions settings</p> <p>Easier method</p> <p>I discovered a little later that it's not necessary to set the Read and write permissions manually if you set the permissions inside of the GitHub action to build the docs like this:</p> <pre><code>jobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n      pages: write\n</code></pre> <p>Once that's done, while you are still in settings, the deployment branch needs to be selected. This is found under the \"Pages\" section on the left. Then, the <code>gh-pages</code> branch and root folder needs to be selected. Any branch can be used for deployment, but the actions-gh-pages action that I use builds the docs in the <code>gh-pages</code> branch by default.</p> <p></p> <p>Screenshot of branch and folder selection</p> <p>Note that you can't actually select the <code>gh-pages</code> branch unless it has been created already. The <code>actions-gh-pages</code> action will do this automatically, but it must have completed successfully first. If it failed after that initial push, it's probably because the \"Read and write permissions\" weren't enabled yet. It's easy to just re-run the action in that case to build the docs.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#summing-up-the-boring-stuff","title":"Summing up the boring stuff","text":"<p>So, now I've described all the setup and scaffolding that I like to include in a Python project. Given all that is here, you can see why it takes a while to get everything into place for a new project. This really is the boring part of a new project. Nothing I've talked about yet is that creative or interesting.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#automating-the-boring-stuff","title":"Automating the boring stuff","text":"<p>There's a seminal book about Python called Automate the Boring Stuff with Python by Al Sweigart that operates on the premise that Python is a great language for automating boring tasks. While the template project that I built doesn't itself use much Python, the sentiment is a good one. The whole point of the template project and this article is how automation takes away the drudgery of setting up a new Python project. So, let's get into the fun part!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#template-engine-selection","title":"Template Engine Selection","text":"<p>There are a few project template engines out there including the most famous: cookiecutter. I've used <code>cookiecutter</code> before, and it's...fine. However, I've also found some sharp edges while using it.</p> <p>Overall, I just wanted to try something new, so I reached for copier.</p> <p><code>copier</code> has a lot of cool features that are unique to it. Really, though, I'm only interested in creating a template to automate setting up a new Python project. After reading over the docs for a bit, I felt good about my selection and got to work.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#template-variables","title":"Template variables","text":"<p>After examining a few of my old project, I identified 5 elements that are essential to a new Python project. With these 5 settings, I can bootstrap a new project that is customized and ready to go. These 5 elements can be defined by template variables that <code>copier</code> learns by asking you interactive questions to get the values. The 5 elements are:</p> <ol> <li><code>project_name</code></li> <li><code>project_summary</code></li> <li><code>module_name</code></li> <li><code>python_versions</code></li> <li><code>default_python_version</code></li> </ol> <p>I'll explain each one in more detail.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#project_name","title":"<code>project_name</code>","text":"<p>This will be the name of the project, the name of the folder that holds it, and the package name on PyPI. In our case study, this is <code>space-monkey</code>.</p> <p>I like my <code>project_name</code> to use kebab case for longer names, and I like the to name to always be lowercase.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#project_summary","title":"<code>project_summary</code>","text":"<p>This is a short description of what the project is and does. It's usually just a sentence long. I use this at the top of the <code>README.md</code>, in the docs, in the <code>pyproject.toml</code>, and on the GitHub page for the project. For <code>space-monkey</code>, let's use \"It's a trial run\" as the <code>project_summary</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#module_name","title":"<code>module_name</code>","text":"<p>This is the name of the Python module from which any source code is imported. Often, this is the same as the <code>project_name</code>. However, if the <code>project_name</code> has dashes in it, a Python module can't include those. Thus it should use snake case. For <code>space-monkey</code>, the <code>module_name</code> becomes <code>space_monkey</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#python_versions","title":"<code>python_versions</code>","text":"<p>These are the versions of Python that the project should support. This should be a consecutive list of Python versions that the project's source code will work in. The full list is used in the GitHub action that runs tests and type-checks on all branches. The range of versions is used in <code>pyproject.toml</code> to identify compatible Python versions for the project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#default_python_version","title":"<code>default_python_version</code>","text":"<p>This should identify the Python version that is used by default in the project. For example, the project might support all the way back to Python 3.9, but I prefer to work in Python 3.13. This is the version that will get set in the <code>.python-version</code> so that <code>uv</code> runs everything in Python 3.13 for <code>space-monkey</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#copieryaml","title":"<code>copier.yaml</code>","text":"<p>Once I knew the key elements for the <code>copier</code> project, I could constrain the questions in the <code>copier</code> configuration file named <code>copier.yaml</code>. This file sits at the root of the template project and defines everything <code>copier</code> needs to know in order to generate a new project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#basic-questions","title":"Basic questions","text":"<p>First, I needed to define the basic questions. So, I started pretty simply:</p> <pre><code>project_name:\n  type: str\n  help: What is the name of the project?\n\nproject_summary:\n  type: str\n  help: Provide a short summary of the project.\n\nmodule_name:\n  type: str\n  help: What is the Python module name?\n</code></pre> <p>This was very straightforward. <code>copier</code> asks the question described by the <code>help</code> field and stores the answer provided by the user in the template variable.</p> <p>However, I realized there was an issue here. What if the user (me) enters the empty string as the <code>project_name</code>? Since this will be used as the name of the folder to hold the project, it obviously must not be the empty string. Additionally, as I said earlier, I want the <code>project_name</code> to be in \"kebab\" case and only include lowercase characters.</p> <p>To make this possible, I used a <code>copier</code> validator. Fortunately, the <code>copier.yaml</code> file can include some <code>jinja</code> in it to make things more dynamic. After setting up my validator, the <code>project_name</code> definition ended up looking like this:</p> <pre><code>project_name:\n  type: str\n  help: What is the name of the project?\n  validator: |\n    {% if project_name|length &lt; 4 or project_name|length &gt; 40 %}\n    project_name must be between 4 and 40 characters\n    {% endif %}\n    {% if not (project_name | regex_search('^[a-z][a-z0-9\\-]+$')) %}\n    project_name must start with a letter, followed one or more letters, digits or dashes (all lowercase).\n    {% endif %}\n</code></pre> <p>Notice that the <code>validator</code> item in the yaml is defined as a multiline string using the <code>|</code> operator. This is because all <code>jinja</code> directives have to be in strings so that the file itself is still valid YAML. Read more in the <code>copier</code> docs about these constraints.</p> <p>Next, I wanted to also constrain the <code>project_summary</code>. I also wanted it to have a default value that was equivalent to the <code>project_name</code> only in \"snake_case\" instead of \"kebab-case\". I ended up writing this definition as:</p> <pre><code>module_name:\n  type: str\n  help: What is the Python module name?\n  default: \"{{ project_name.replace('-', '_') }}\"\n  validator: |\n    {% if module_name|length &lt; 4 or module_name|length &gt; 40 %}\n    module_name must be between 4 and 40 characters\n    {% endif %}\n    {% if not (module_name | regex_search('^[a-z][a-z0-9_]+$')) %}\n    module_name must start with a letter, followed one or more letters, digits or underscores (all lowercase).\n    {% endif %}\n</code></pre> <p>I decided that I didn't care if the <code>project_summary</code> was empty, so I didn't add a validator for it.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#choices","title":"Choices","text":"<p>For the <code>python_versions</code> question, I needed to define a set of choices that the user can choose from to limit the answer for the supported versions of Python. This keeps the user from selecting a version of python that doesn't exist or isn't supported any more:</p> <pre><code>python_versions:\n  type: str\n  default:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n  multiselect: true\n  choices:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n</code></pre> <p>This works by limiting the choices to Python 3.9 through 3.13. Because I enabled <code>multiselect</code> the user can select more than one Python version to include. Additionally, I set the default to all available versions to just make things easier.</p> <p>If you have a discerning eye, you might notice a problem here. I will be using these Python versions in <code>pyproject.toml</code> to identify what versions my project should work with. However (according to it's specification) <code>pyproject.toml</code> can only specify a range of versions if more than one must be supported. Thus, I could have an issue if the selected versions were not consecutive. Choosing 3.10, 3.12, 3.13 while leaving out 3.11 would be problematic. To address this, I figured out a validator that can handle this constraint:</p> <pre><code>python_versions:\n  type: str\n  help: What Python versions will be supported?\n  default:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n  multiselect: true\n  choices:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n  validator: |\n    {% set all_ver = [\"3.9\", \"3.10\", \"3.11\", \"3.12\", \"3.13\"] %}\n    {% if all_ver.index(python_versions[-1]) - all_ver.index(python_versions[0]) + 1 != python_versions|length %}\n    python_versions must be a consecutive list of versions\n    {% endif %}\n</code></pre> <p>Next, I needed to create a question for the <code>default_python_version</code>. Right away, it was clear that this had to be constrained to be one of the values chosen for <code>python_versions</code>. Additionally, I wanted this to default to the latest supported Python version from the selected list. To make this happen, I made <code>default_python_version</code> quite dynamic:</p> <pre><code>default_python_version:\n  type: str\n  help: What is the default Python version to use?\n  default: \"{{python_versions[-1]}}\"\n  choices: |\n    {% for ver in python_versions %}\n    - \"{{ver}}\"\n    {% endfor %}\n</code></pre> <p>With that, I'd finished defining the questions needed to define the 5 critical template variables needed for a new project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#building-out-the-project-structure","title":"Building out the project structure","text":"<p><code>copier</code> uses Jinja to inject the values for the template variables it gathers from the questionnaire into not only the contents of the project template files, but into their filenames as well. To inject into files, the files must be of type <code>.jinja</code>.</p> <p>Remember my directory structure that I laid out before? Well, now I need to convert some of those files into Jinja templates so that I can get the correct values into them. To fast-forward a bit, the file structure now looks like this:</p> <pre><code>{{project_name}}/\n\u2514\u2500\u2500 .github/\n    \u251c\u2500\u2500 workflows/\n    \u2502   \u251c\u2500\u2500 deploy.yml.jinja\n    \u2502   \u251c\u2500\u2500 docs.yml.jinja\n    \u2502   \u2514\u2500\u2500 main.yml.jinja\n    \u251c\u2500\u2500 docs/\n    \u2502   \u251c\u2500\u2500 source/\n    \u2502   \u2502   \u251c\u2500\u2500 features.md\n    \u2502   \u2502   \u251c\u2500\u2500 index.md.jinja\n    \u2502   \u2502   \u251c\u2500\u2500 quickstart.md.jinja\n    \u2502   \u2502   \u2514\u2500\u2500 reference.md.jinja\n    \u2502   \u2514\u2500\u2500 mkdocs.yaml.jinja\n    \u251c\u2500\u2500 src/\n    \u2502   \u2514\u2500\u2500 {{module_name}}/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 main.py\n    \u2502       \u2514\u2500\u2500 py.typed\n    \u2514\u2500\u2500 tests/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u2514\u2500\u2500 test_main.py.jinja\n</code></pre> <p>Every file that has a <code>.jinja</code> extension needs to have one of the 5 values injected into it. Additionally, the root folder should use the selected <code>project_name</code>, and the module in the <code>src</code> directory should use the <code>module_name</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#making-a-templated-file","title":"Making a templated file","text":"<p>To show how Jinja template variable injections work, check out the internals of one of the templated files:</p> <pre><code>name: QA on push\nrun-name: qa-checks\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version:\n          {% for ver in python_versions -%}\n          - '{{ ver }}'\n          {% endfor %}\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v4\n\n    - name: Install uv\n      uses: astral-sh/setup-uv@v5\n\n    - name: Install python\n      run:  uv python install {{ \"${{ matrix.python-version }}\" }}\n\n    - name: Check Quality\n      run: make qa\n\n    - name: Upload coverage reports to Codecov\n      uses: codecov/codecov-action@v5\n      with:\n        files: ./.coverage.xml\n        token: {{ \"${{ secrets.CODECOV_TOKEN }}\" }}\n      if: {{ \"${{ !cancelled() }}\" }}\n\n    - name: Upload test results to Codecov\n      uses: codecov/test-results-action@v1\n      with:\n        token: {{ \"${{ secrets.CODECOV_TOKEN }}\" }}\n        files: ./.junit.xml\n      if: {{ \"${{ !cancelled() }}\" }}\n</code></pre> <p>There's a few interesting things to take note of here. First, you can see that we are using the <code>python_versions</code> from before to tell the GitHub action the matrix of versions to use in the test runs. It will create a separate run of the test job for every version that was selected before.</p> <p>Note down in the \"Install python\" step, there's something wild going on. In a vanilla GitHub action YAML file, this section would look like:</p> <pre><code>    - name: Install python\n      run:  uv python install ${{ matrix.python-version }}\n</code></pre> <p>However, because it's a Jinja file now, double curly braces mean something special. Consequently, we need to escape the existing double curly braces. The Jinja way to do this is to make the original double curly expression a string and surround it again with double curlies. It's ugly, but it gets the job done:</p> <pre><code>    - name: Install python\n      run:  uv python install {{ \"${{ matrix.python-version }}\" }}\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#creating-a-template-folder","title":"Creating a template folder","text":"<p>By default, <code>copier</code> expects the templated project files to live in the same directory as <code>copier.yaml</code>. However, because I have lots of other files that I want as a part of my template project, that wasn't going to work for me. Fortunately, <code>copier</code> allows you to identify a different subdirectory that holds your template. So, I packaged up the whole project structure in a <code>template</code> subdirectory and updated my <code>copier.yaml</code> file to include a subdirectory section like this:</p> <pre><code>_subdirectory: template\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#generating-a-new-project","title":"Generating a new project","text":"<p>Now that everything is in place, it was time to generate a new project. So, I kicked off copier with the following command:</p> <pre><code>uv run copier copy . ..\n</code></pre> <p>Basically, I was telling <code>copier</code> to create the new project using the template defined in the current directory. Additionally, I wanted the new project to be created in the parent of my template project. Thus, the new project live in a sibling folder of my template project's root.</p> <p>Next, I ran through the questionnaire as follows:</p> <pre><code>\ud83c\udfa4 What is the name of the project?\n   space-monkey\n\ud83c\udfa4 Provide a short summary of the project.\n   It's a trial run\n\ud83c\udfa4 What is the Python module name?\n   space_monkey\n\ud83c\udfa4 What Python versions will be supported?\n   done (3 selections)\n\ud83c\udfa4 What is the default Python version to use?\n   3.13\n\nCopying from template version 0.0.0.post3.dev0+c69bc53\n    create  space-monkey\n    create  space-monkey/.python-version\n    create  space-monkey/src\n    create  space-monkey/src/space_monkey\n    create  space-monkey/src/space_monkey/main.py\n    create  space-monkey/src/space_monkey/__init__.py\n    create  space-monkey/src/space_monkey/py.typed\n    create  space-monkey/.gitignore\n    create  space-monkey/tests\n    create  space-monkey/tests/test_main.py\n    create  space-monkey/tests/conftest.py\n    create  space-monkey/tests/__init__.py\n    create  space-monkey/Makefile\n    create  space-monkey/CHANGELOG.md\n    create  space-monkey/docs\n    create  space-monkey/docs/mkdocs.yaml\n    create  space-monkey/docs/source\n    create  space-monkey/docs/source/features.md\n    create  space-monkey/docs/source/index.md\n    create  space-monkey/docs/source/reference.md\n    create  space-monkey/docs/source/quickstart.md\n    create  space-monkey/.github\n    create  space-monkey/.github/workflows\n    create  space-monkey/.github/workflows/deploy.yml\n    create  space-monkey/.github/workflows/main.yml\n    create  space-monkey/.github/workflows/docs.yml\n    create  space-monkey/README.md\n    create  space-monkey/LICENSE.md\n    create  space-monkey/pyproject.toml\n</code></pre> <p>GREAT! It worked! Now I have a new Python project that includes all the scaffolding I like to have, and it's ready to build on.</p> <p>However, this doesn't fix the pain of having to set up git and GitHub. I still would have to do those manual steps to complete the process.</p> <p>So, I decided to investigate if I those steps could be automated as well.</p> <p>SPOILER ALERT</p> <p>They could be automated!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#automating-github-deployment-with-tasks","title":"Automating GitHub Deployment with Tasks","text":"<p>With the Python project setup all automated, I needed to find out what I could do about automating the manual steps that are needed to roll the project out to GitHub. Remember that in the Processes section, I described 3 manual steps that I needed to perform in order to get a new project up on GitHub:</p> <ol> <li>Initialize the git repo</li> <li>Host it on GitHub</li> <li>Set up a GitHub Page</li> </ol> <p>All these steps happen after the project is functional in its MVP form and ready to make public. So, I dug deeper into <code>copier</code> to see what it offered for automating steps like this.</p> <p>It turns out that <code>copier</code> supports tasks that run after the project is generated. This fit my needs perfectly! However, in reading the docs on <code>_tasks</code>, something pretty important jumped out:</p> <p>Copier templates can use dangerous features that allow arbitrary code execution:</p> <ul> <li>Jinja extensions</li> <li>Migrations</li> <li>Tasks</li> </ul> <p>Therefore, these features are disabled by default and Copier will raise an error (and exit from the CLI with code 4) when they are found in a template. In this case, please verify that no malicious code gets executed by any of the used features. When you're sufficiently confident or willing to take the risk, set unsafe=True or pass the CLI switch --UNSAFE or --trust.</p> <p>This sounds pretty scary, BUT! I am building this project template for my own use. I think I can trust executable code that I wrote myself--though sometimes I wonder! All I needed to add to take advantage of the <code>_tasks</code> directive was a <code>--trust</code> flag in the <code>copier</code> command:</p> <pre><code>uv run copier copy --trust . ..\n</code></pre> <p>With that handled, I worked on my tasks next.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-1-make-sure-the-project-works","title":"Task 1: Make sure the project works","text":"<p>I decided that it would be really nice to make sure that the project is actually working as expected before I pulbished it on GitHub. Since I already added commands for linting, unit tests, and type-checks to my <code>Makefile</code>, I could verify that the basics in the project work with a single command: <code>make qa</code>. I added this to the <code>_tasks</code> section with a single command:</p> <pre><code>_tasks:\n  - working_directory: \"{{ project_name }}\"\n    command: \"make qa\"\n</code></pre> <p>Notice that this command sets the working directory to the <code>project_name</code>. That meant that this command is actually executed in the generated project. I don't need to make the directory path relative to the path where I run the command because I have already directed <code>copier</code> to execute the template in the parent directory of the template project (remember the <code>..</code>). Thus, the command will be executed exactly where I wanted. I took the new task for a spin:</p> <pre><code>\ud83c\udfa4 What is the name of the project?\n   space-monkey\n\ud83c\udfa4 Provide a short summary of the project.\n   It's a trial run\n\ud83c\udfa4 What is the Python module name?\n   space_monkey\n\ud83c\udfa4 What Python versions will be supported?\n   done (3 selections)\n\ud83c\udfa4 What is the default Python version to use?\n   3.13\n\nCopying from template version 0.0.0.post3.dev0+4a481f3\n...\n\n &gt; Running task 1 of 1: make qa\nmake[1]: Entering directory '/home/dusktreader/git-repos/personal/space-monkey'\nuv run pytest\n...\ntests/test_main.py .                                                                                                                                                                                         [100%]\n...\nuv run ruff check src/space_monkey tests\nAll checks passed!\nuv run mypy src/space_monkey tests --pretty\nuv run basedpyright src/space_monkey tests\nSuccess: no issues found in 5 source files\n0 errors, 0 warnings, 0 notes\necho \"All quality checks pass!\"\nAll quality checks pass!\nmake[1]: Leaving directory '/home/dusktreader/git-repos/personal/space-monkey'\n</code></pre> <p>I omitted some output (...) here to make save some space. Still, you can see that it ran my QA checks after generating the project and all of the checks passed. Great! Now I'm confident that the generated project had a baseline of functinoality.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-2-6-initialize-the-git-repository","title":"Task 2-6: Initialize the git repository","text":"<p>The next series of tasks covered the manual steps I described to initialize the git repository. These steps are really easy to define in tasks:</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: \"git init .\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git add README.md\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git commit -m 'Initial Commit'\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git add .\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git commit -m 'feat: Bootstrapped the {{ project_name }} project'\"\n</code></pre> <p>There's not much to comment on here other than the nicety of including the templated <code>project_name</code> value in the first git commit message. The output from this steps (with some stuff removed) looked like this:</p> <pre><code> &gt; Running task 2 of 6: git init .\nInitialized empty Git repository in /home/dusktreader/git-repos/personal/space-monkey/.git/\n &gt; Running task 3 of 6: git add README.md\n &gt; Running task 4 of 6: git commit -m 'Initial Commit'\n[main (root-commit) 4106d13] Initial Commit\n 1 file changed, 29 insertions(+)\n create mode 100644 README.md\n &gt; Running task 5 of 6: git add .\n &gt; Running task 6 of 6: git commit -m 'feat: Bootstrapped the space-monke`y project'\n[main d830fcb] feat: Bootstrapped the space-monkey project\n 21 files changed, 1339 insertions(+)\n ...\n</code></pre> <p>Now, I was really getting somewhere on automating boring steps!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-7-8-create-the-project-on-github","title":"Task 7 &amp; 8: Create the project on GitHub","text":"<p>For the next two steps, I needed to be able to interact with GitHub from the command-line. Fortunately, GitHub had a very powerful CLI available that can do it all! I just had to install it. The installation wasn't super clean, but after following the instructions in the docs, I had GitHub CLI up and running. Next, I needed to login through the CLI to my GitHub account:</p> <pre><code>gh auth login\n</code></pre> <p>After following the steps to complete device authorization flow, I was fully logged in.</p> <p>Next, I defined the steps to create the project on GitHub and push my <code>main</code> branch to the new origin.</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: \"gh repo create --description=\\\"{{ project_summary }}\\\" --source=. --public {{ project_name }}\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git push -u origin main\"\n</code></pre> <p>The <code>create</code> command is really straightforward, and it's nice that I could use the <code>project_summary</code> as the project description on GitHub. Executing the tasks looked like this:</p> <pre><code> &gt; Running task 7 of 8: gh repo create --description=\"It's a trial run\" --source=. --public space-monkey\n2025/04/06 11:28:35.534717 cmd_run.go:1285: WARNING: cannot start document portal: dial unix /run/user/1000/bus: connect: connection refused\n\u2713 Created repository dusktreader/space-monkey on GitHub\n\u2713 Added remote git@github.com:dusktreader/space-monkey.git\n &gt; Running task 8 of 8: git push -u origin main\nEnumerating objects: 30, done.\nCounting objects: 100% (30/30), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (23/23), done.\nWriting objects: 100% (30/30), 30.07 KiB | 2.15 MiB/s, done.\nTotal 30 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)\nremote: Resolving deltas: 100% (1/1), done.\nTo github.com:dusktreader/space-monkey.git\n * [new branch]      main -&gt; main\nbranch 'main' set up to track 'origin/main'.\n</code></pre> <p>When I went to check the repo on GitHub, I could see that it was all set up!</p> <p></p> <p>space-monkey now on GitHub!</p> <p></p> <p>about section has the summary</p> <p></p> <p>space-monkey README</p> <p>And, when I checked the Actions, I verified that the docs build succeeded as well:</p> <p></p> <p>space-monkey build-docs action</p> <p>However, the GitHub Pages site for the docs was not built yet, because it wasn't configured as I described in the GitHub Pages section. So, I needed a few more actions to make that happen.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-9-11-publish-the-github-page","title":"Task 9-11: Publish the GitHub Page","text":"<p>Figuring out how to configure my repo to publish the GitHub Pages site took some digging. I found that this functionality isn't actually built in to the GitHub CLI directly. However, the CLI does allow you to call any API endpoint provided by GitHub! Once I learned that, it was only a matter of finding the endpoint and learning how to call it. The complete CLI command looked like this (I've broken it up into several lines to make it easier to read):</p> <pre><code>gh api \\\n  --method=POST \\\n  -H \"Accept: application/vnd.github+json\" \\\n  \"/repos/dusktreader/so-dumb/pages\" \\\n  -f \"source[branch]=gh-pages\" \\\n  -f \"source[path]=/\" \\\n  -f \"build_type=legacy\"\n</code></pre> <p>It worked, but I quickly realized there was a problem. This command will only work after the GitHub action to build the docs is completed. That action creates a new branch in the repo called <code>gh-pages</code> where the built docs are staged. If you try to run the GitHub API command before that branch exists, it will fail.</p> <p>So, I needed to make sure that the <code>build-docs</code> action completed before I ran the command. That took even more digging, but I was able to figure out how to do it in two steps:</p> <ol> <li>Wait for the <code>build-docs</code> action to start</li> <li>Once it's started, wait for it to complete</li> </ol> <p>After refining those steps into tasks, my YAML looked like this:</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"build-docs\")')\" ]; do\n        echo \"Waiting for docs build action to start\" &amp;&amp; sleep 1;\n      done\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      gh run list --json databaseId,name\n      | jq '.[] | select(.name == \"build-docs\")'\n      | jq '.databaseId'\n      | xargs gh run watch --exit-status\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      gh api\n      --silent\n      --method=POST\n      -H \"Accept: application/vnd.github+json\"\n      \"/repos/dusktreader/{{ project_name }}/pages\"\n      -f \"source[branch]=gh-pages\"\n      -f \"source[path]=/\"\n      -f \"build_type=legacy\"\n</code></pre> <p>Once I had the tasks in place, running it produced this output:</p> <pre><code> &gt; Running task 9 of 10: while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"build-docs\")')\" ]; do\n  echo \"Waiting for docs build action to start\" &amp;&amp; sleep 1;\ndone\n\nWaiting for docs build action to start\nWaiting for docs build action to start\nWaiting for docs build action to start\n &gt; Running task 10 of 10: gh run list --json databaseId,name | jq '.[] | select(.name == \"build-docs\")' | jq '.databaseId' | xargs gh run watch --exit-status\n\nRefreshing run status every 3 seconds. Press Ctrl+C to quit.\n\n\u2713 main build-docs \u00b7 14295750274\nTriggered via push less than a minute ago\n\nJOBS\n\u2713 build in 12s (ID 40062668601)\n  \u2713 Set up job\n  \u2713 Checkout repository\n  \u2713 Install uv\n  \u2713 Set up Python\n  \u2713 Build Documentation\n  \u2713 Deploy documentation\n  \u2713 Post Install uv\n  \u2713 Post Checkout repository\n  \u2713 Complete job\n\n\u2713 Run build-docs (14295750274) completed with 'success'\n &gt; Running task 11 of 11: gh api --method=POST -H \"Accept: application/vnd.github+json\" \"/repos/dusktreader/space-monkey/pages\" -f \"source[branch]=gh-pages\" -f \"source[path]=/\" -f \"build_type=legacy\"\n</code></pre> <p>That's it! My project is now available on GitHub and the docs page is also built...well, not yet actually. The page wasn't deployed yet because the final GitHub action named \"pages build and deployment\" had to finish first. So, I decided to add one last finishing touch.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-12-14-wrapping-it-up","title":"Task 12-14: Wrapping it up","text":"<p>For this final step, I just needed to add another task to wait for the page deployment to complete. I also wanted to add a message at the end confirming that the tasks completed successfully and include a URL to the new GitHub repo so that I could open it with a click. The final tasks looked like this:</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"pages build and deployment\")')\" ]; do\n        echo \"Waiting for page deploy action to start\" &amp;&amp; sleep 1;\n      done\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      gh run list --json databaseId,name\n      | jq '.[] | select(.name == \"pages build and deployment\")'\n      | jq '.databaseId'\n      | xargs gh run watch --exit-status\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      echo \"Finished bootstrapping {{ project_name }}!\" &amp;&amp;\n      echo \"Check it out at https://github.com/dusktreader/{{ project_name }}\"\n</code></pre> <p>This produced output from <code>copier</code> that looked like this:</p> <pre><code> &gt; Running task 12 of 14: while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"pages build and deployment\")')\" ]; do\n  echo \"Waiting for page deploy action to start\" &amp;&amp; sleep 1;\ndone\n\nWaiting for docs build action to start\nWaiting for docs build action to start\nWaiting for docs build action to start\n &gt; Running task 13 of 14: gh run list --json databaseId,name | jq '.[] | select(.name == \"pages build and deployment\")' | jq '.databaseId' | xargs gh run watch --exit-status\nRefreshing run status every 3 seconds. Press Ctrl+C to quit.\n\n\u2713 gh-pages pages build and deployment \u00b7 14295984823\nTriggered via dynamic less than a minute ago\n\nJOBS\n\u2713 build in 7s (ID 40063197951)\n  \u2713 Set up job\n  \u2713 Checkout\n  \u2713 Upload artifact\n  \u2713 Post Checkout\n  \u2713 Complete job\n\u2713 report-build-status in 3s (ID 40063199711)\n  \u2713 Set up job\n  \u2713 Report Build Status\n  \u2713 Complete job\n\u2713 deploy in 10s (ID 40063199712)\n  \u2713 Set up job\n  \u2713 Deploy to GitHub Pages\n  \u2713 Complete job\n\n\u2713 Run pages build and deployment (14295984823) completed with 'success'\n &gt; Running task 14 of 14: echo \"Finished bootstrapping space-monkey!\" &amp;&amp; echo \"Check it out at https://github.com/dusktreader/space-monkey\"\n\nFinished bootstrapping space-monkey!\nCheck it out at https://github.com/dusktreader/space-monkey\n</code></pre> <p>Excellent! I clicked on the URL at the end and checked out the docs:</p> <p></p> <p>space-monkey docs page!</p> <p>There they were! After all that work, my template project was ready to stamp out new Python projects!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#conclusion","title":"Conclusion","text":"<p>My template project was pretty much complete at this point. It could produce a mostly empty Python project, but all of the scaffolding was complete and the project was published on GitHub.</p> <p>Running the whole process took just over a minute:</p> <pre><code>real    1m15.743s\nuser    0m8.678s\nsys     0m2.462s\n</code></pre> <p>I am really happy with how this turned out. Still, I don't think the template project is 100% done yet. In particular, there are a few things I'd like to improve in it:</p> <ol> <li>Cleaning up some of the output so it's not so noisy</li> <li>Encapsulating the GitHub CLI commands in scripts to make the YAML more concise</li> <li>Figuring out how to seed the list of python versions with a reusable variable</li> <li>Making the GitHub user account a question so other people can use the template more easily</li> <li>Adding some optional components so I can bootstrap CLI apps vs API apps</li> <li>Configuring GitHub to set the URL of the docs page in the \"About\" section</li> </ol> <p>This is a solid start, though, and definitely a tool that I will find really useful for future Python projects.</p> <p>If you are interested in the nitty-gritty details of the template, please check out my xerox-python project on GitHub. Comments, issues, and PRs are always welcome.</p> <p>Before I take off, I'd like to thank the maintiners of <code>copier</code> for creating such a great template builder. It really was a joy to work with!</p> <p>So, what do you think? Let me know below in the comments.</p> <p>Thanks for reading!</p>","tags":["Python","copier","uv"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/","title":"Introducing Typerdrive: Develop API-Connected Typer Apps at Lightspeed","text":"<p>TLDR</p> <p>I created a package to extend Typer with some great features for building CLIs that communicate with APIs.</p> <p>During my time as an engineer working primarily with Python, I've written a a fair number of CLIs powered by Typer. One type of project that has been popping up for me a lot lately involves writing CLI programs that interface with RESTful APIs. These are pretty common these days with so many service companies offering fully operational battlestations...I mean, platforms that can be accessed via API.</p> <p>I've established some pretty useful and re-usable patterns in building these kinds of apps, and I keep finding new ways to improve both the developer experience and the user experience. Every time I go about porting some feature across to a new or old CLI, I wish there was a library that wrapped them all up in a nice package. Now, there is:</p> <p> </p> <p>She may not look like much, but she\u2019s got it where it counts, kid. I\u2019ve made a lot of special modifications myself. --Han Solo</p> <p>These are the challenges I found myself facing repeatedly when building CLIs that talk to APIs:</p> <ul> <li>Settings management: so you're not providing the same values as arguments over and over</li> <li>Cache management: to store auth tokens you use to access a secure API</li> <li>Handling errors: repackaging ugly errors and stack traces into nice user output</li> <li>Client management: serializing data into and out of your requests</li> <li>Logging management: storing and reviewing logs to diagnose errors</li> </ul> <p><code>typerdrive</code> wraps all this up into an interface that's easy for users and developers as well.</p> <p>Each of these feature is fully documented in the <code>typerdrive</code> docs. There are also a full set of examples and demos showing how to use them. Still, I thought it would be good to show how they could be used in actual app. I'm going to go over that with you in this walkthrough!</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#setup","title":"Setup","text":"<p>First of all, the complete code for the \"tutorial\" app is available in its own github repository called typerdrive-tutorial. So, if you want to just dig in and see how it works, you can start there.</p> <p>I'm going to incrementally build this code as I walk through the features of <code>typerdrive</code> and how they are useful for both users and developers.</p> <p>This walkthrough will show you how to use <code>typerdrive</code> to build a CLI that accesses secured API endpoints. To make this setup as easy as possible, I'm using a FastAPI instance secured with <code>armasec</code>.</p> <p>Bias alert</p> <p>I wrote <code>armasec</code>, so my opinion on how easy it is to use is probably a bit biased.</p> <p>So, to prepare things for this app, I followed the instructions here to set up Auth0 with <code>armasec</code> as documented in this guide.</p> <p>To keep things lean and simple, I skipped the steps involved with setting up RBAC. Enabling RBAC won't hurt anything, but it's not necessary for this tutorial.</p> <p>If you want to follow along on your own machine, you will need to complete the setup of an Auth0 client for yourself. You can do this for free with Auth0.</p> <p>If you are feeling ambitious, you could do all this with a local Keycloak instance as well by following this guide. Note that the URLs used to access Keycloak are different than those for Auth0, so you will need to modify the code provided in this walkthrough in some places.</p> <p>OK, once you have an OIDC (Auth0 or Keycloak) provider setup, you are ready to follow along.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#the-api","title":"The API","text":"<p>The API itself is really basic. It has two endpoints:</p> <ul> <li><code>/unsecured</code>: allows access to anyone</li> <li><code>/secured</code>: requires a logged in user</li> </ul> <p>The code for this API is really straightforward:</p> api.py<pre><code>from fastapi import FastAPI, Depends\nfrom armasec import Armasec\n\n\napp = FastAPI()\narmasec = Armasec(\n    domain=\"typerdrive-tutorial.us.auth0.com\",\n    audience=\"typerdrive-tutorial\",\n)\n\n\n@app.get(\"/unsecured\")\nasync def unsecured():\n    return dict(message=\"Accessed unsecured endpoint!\")\n\n\n@app.get(\"/secured\", dependencies=[Depends(armasec.lockdown())])\nasync def check_access():\n    return dict(message=\"Accessed secured endpoint!\")\n</code></pre> <p>If you are following along, you will have to replace the <code>Armasec</code> values for <code>domain</code> and <code>audience</code> with whatever you selected during the Auth0 setup.</p> <p>That's it. This FastAPI app will use <code>armasec</code> to secure the <code>/secured</code> endpoint. The <code>/unsecured</code> endpoint has no such protection.</p> <p>Start the API up by running:</p> <pre><code>fastapi dev src/typerdrive_tutorial/api.py\n</code></pre> <p>This will start up a local instance of the API running on port 8000. To see the available endpoints, you can open a browser with <code>http://localhost:8000/docs</code></p> <p>That's it. The API is ready to receive both secured and unsecured requests. Let's test it out by hitting the unsecured endpoint with cURL:</p> <pre><code>$ curl -i http://localhost:8000/unsecured\nHTTP/1.1 200 OK\ndate: Mon, 12 May 2025 16:13:08 GMT\nserver: uvicorn\ncontent-length: 42\ncontent-type: application/json\n\n{\"message\":\"Accessed unsecured endpoint!\"}\n</code></pre> <p>Great! The API is working. Of course, if you try to access the secured endpoint it will give you a 401 because you're not (yet) providing an auth header:</p> <pre><code>$ curl -i http://localhost:8000/secured\nHTTP/1.1 401 Unauthorized\ndate: Mon, 12 May 2025 16:13:30 GMT\nserver: uvicorn\nwww-authenticate: Bearer\ncontent-length: 30\ncontent-type: application/json\n\n{\"detail\":\"Not authenticated\"}\n</code></pre> <p>Great! The API is ready to process requests from the CLI.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#building-the-cli","title":"Building the CLI","text":"<p>Now that the API is ready to go, we can start building our CLI with <code>typerdrive</code>.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-1-create-the-cli-skeleton","title":"Step 1: Create the CLI skeleton","text":"<p>In this tutorial, we will build a CLI that has two main commands:</p> <ul> <li><code>login</code>: Log in to Auth0 and get an access token</li> <li><code>access</code>: Access secured or unsecured endpoints</li> </ul> <p>More commands incoming</p> <p>As we integrate <code>typerdrive</code>, more commands will become available, and those will be explained as we go.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#initial-code","title":"Initial code","text":"<p>First, we'll set up the skeleton of our API with the two commands like so:</p> cli.py<pre><code>import typer\nfrom typerdrive import terminal_message\n\n\napp = typer.Typer()\n\n\n@app.command()\ndef access():\n    terminal_message(\"Processing access command\")\n\n\n@app.command()\ndef login():\n    terminal_message(\"Processing login command\")\n</code></pre> <p>Now, this bare-bones CLI won't really do anything, it just prints a message for either command.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands","title":"Running the commands","text":"<p>Let's try it out:</p> <pre><code>$ typerdrive-tutorial access\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Processing access command                                                  \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The <code>terminal_message()</code> function imported from <code>typerdrive</code> just prints nicely formatted messages with <code>rich</code>. You can make the output much fancier, as you will see later in this walkthrough.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-2-use-an-http-client-to-access-api-endpoints","title":"Step 2: Use an http client to access API endpoints","text":"<p>Let's start building out functionality by using an http client to access the API endpoints.</p> <p>First, we'll use a vanilla <code>httpx</code> client to issue requests to the API.</p> <p>Why httpx and not requests?</p> <p>I vastly prefer <code>httpx</code> over <code>requests</code>; that's why this tutorial and <code>typerdrive</code> itself uses it. <code>typerdrive</code> includes <code>httpx</code> as a dependency, so you will not need to install it separately.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-code","title":"Updated code","text":"<p>Let's update the <code>access()</code> function like this:</p> cli.py<pre><code>from enum import StrEnum, auto\n\nimport httpx\nimport typer\nfrom typerdrive import terminal_message\n\n\nclass Endpoint(StrEnum):\n    unsecured = auto()\n    secured = auto()\n\n\napp = typer.Typer()\n\n\n@app.command()\ndef access(endpoint: Endpoint):\n    response = httpx.get(f\"http://localhost:8000/{endpoint}\")\n    response.raise_for_status()\n    message = response.json()[\"message\"]\n    terminal_message(\n        message,\n        subject=\"Successfully connected to API\",\n        footer=f\"Status Code: {response.status_code}\",\n    )\n\n\n@app.command()\ndef login():\n    terminal_message(\"Processing login command\")\n</code></pre> <p>Let's walk through what's going on here:</p> <p>First, we add an <code>Endpoint</code> enum so that we can add a Typer <code>argument</code> that controls which endpoint we send a request to. If you run the CLI with the <code>--help</code> command, you can see that it requires you to supply either \"unsecured\" or \"secured\" for this argument:</p> <pre><code>$ typerdrive-tutorial access --help\n\n Usage: typerdrive-tutorial access [OPTIONS] ENDPOINT:{unsecured|secured}\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    endpoint      ENDPOINT:{unsecured|secured}  [default: None] [required]  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>The request is sent to the API via <code>httpx</code> at the chosen endpoint. Notice that we included <code>response.raise_for_status()</code>? This will simply throw an exception if any error responses are returned. Error responses have http status codes in the 400 and 500 range.</p> <p>Next, we unpack the \"message\" from the response payload and show it to the user with a fancier version of <code>terminal_message()</code>.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands_1","title":"Running the commands","text":"<p>Let's try it out:</p> <pre><code>$ typerdrive-tutorial access unsecured\n\n\u256d\u2500 Successfully connected to API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   API response: {'message': 'Accessed unsecured endpoint!'}                  \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Status Code: 200 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Awesome! We connected to the API and got a 200 response from the <code>/unsecured</code> endpoint. This is exactly what we wanted to see. So, now what happens when we hit the <code>/secured</code> endpoint?</p> <pre><code>$ typerdrive-tutorial access secured\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Traceback (most recent call last) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 /home/dusktreader/git-repos/personal/typerdrive-tutorial/src/typerdrive_tuto \u2502\n\u2502 rial/cli.py:19 in access                                                     \u2502\n\u2502                                                                              \u2502\n\u2502   16 @app.command()                                                          \u2502\n\u2502   17 def access(endpoint: Endpoint):                                         \u2502\n\u2502   18 \u2502   response = httpx.get(f\"http://localhost:8000/{endpoint}\")           \u2502\n\u2502 \u2771 19 \u2502   response.raise_for_status()                                         \u2502\n\u2502   20 \u2502   message = response.json()[\"message\"]                                \u2502\n\u2502   21 \u2502   terminal_message(                                                   \u2502\n\u2502   22 \u2502   \u2502   message,                                                        \u2502\n\u2502                                                                              \u2502\n\u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 locals \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e                                 \u2502\n\u2502 \u2502 endpoint = &lt;Endpoint.secured: 'secured'&gt; \u2502                                 \u2502\n\u2502 \u2502 response = &lt;Response [401 Unauthorized]&gt; \u2502                                 \u2502\n\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f                                 \u2502\n\u2502                                                                              \u2502\n\u2502 /home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.1 \u2502\n\u2502 3/site-packages/httpx/_models.py:829 in raise_for_status                     \u2502\n\u2502                                                                              \u2502\n\u2502    826 \u2502   \u2502   }                                                             \u2502\n\u2502    827 \u2502   \u2502   error_type = error_types.get(status_class, \"Invalid status co \u2502\n\u2502    828 \u2502   \u2502   message = message.format(self, error_type=error_type)         \u2502\n\u2502 \u2771  829 \u2502   \u2502   raise HTTPStatusError(message, request=request, response=self \u2502\n\u2502    830 \u2502                                                                     \u2502\n\u2502    831 \u2502   def json(self, **kwargs: typing.Any) -&gt; typing.Any:               \u2502\n\u2502    832 \u2502   \u2502   return jsonlib.loads(self.content, **kwargs)                  \u2502\n\u2502                                                                              \u2502\n\u2502 \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 locals \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e \u2502\n\u2502 \u2502   error_type = 'Client error'                                            \u2502 \u2502\n\u2502 \u2502  error_types = {                                                         \u2502 \u2502\n\u2502 \u2502                \u2502   1: 'Informational response',                          \u2502 \u2502\n\u2502 \u2502                \u2502   3: 'Redirect response',                               \u2502 \u2502\n\u2502 \u2502                \u2502   4: 'Client error',                                    \u2502 \u2502\n\u2502 \u2502                \u2502   5: 'Server error'                                     \u2502 \u2502\n\u2502 \u2502                }                                                         \u2502 \u2502\n\u2502 \u2502      message = \"Client error '401 Unauthorized' for url                  \u2502 \u2502\n\u2502 \u2502                'http://localhost:8000/secured'\\nFor more\"+80             \u2502 \u2502\n\u2502 \u2502      request = &lt;Request('GET', 'http://localhost:8000/secured')&gt;         \u2502 \u2502\n\u2502 \u2502         self = &lt;Response [401 Unauthorized]&gt;                             \u2502 \u2502\n\u2502 \u2502 status_class = 4                                                         \u2502 \u2502\n\u2502 \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nHTTPStatusError: Client error '401 Unauthorized' for url\n'http://localhost:8000/secured'\nFor more information check:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401\n</code></pre> <p>This should be expected. Without a valid auth token, the secured endpoint will reject the request with a <code>401: Not Authenticated</code> response. However, this is a very unfriendly message to show to your users. That stack trace might be super valuable to you, a developer, who needs to find out what went wrong, but it will confuse the hell out of any enduser that's using your app.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-3-handling-errors","title":"Step 3: Handling errors","text":"<p>It can be toilsome to handle error conditions to make sure that you are providing friendlier output for the end user. You will find yourself using the same code over and over to capture an error and re-format it nicely as well as exiting gracefully.</p> <p><code>typerdrive</code> provides error handling that can make this much easier for you and nice for your users as well.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-code_1","title":"Updated code","text":"<p>Let's update the code to add error handling:</p> cli.py<pre><code>from enum import StrEnum, auto\n\nimport httpx\nimport typer\nfrom typerdrive import terminal_message, handle_errors, TyperdriveError\n\n\nclass Endpoint(StrEnum):\n    unsecured = auto()\n    secured = auto()\n\n\nclass TutorialError(TyperdriveError):\n    pass\n\n\napp = typer.Typer()\n\n\n@app.command()\n@handle_errors(\"Failed to access the API\")\ndef access(endpoint: Endpoint):\n    response = httpx.get(f\"http://localhost:8000/{endpoint}\")\n    TutorialError.require_condition(\n        response.status_code == 200,\n        f\"Expected status code 200, but got {response.status_code}\",\n    )\n    message = response.json()[\"message\"]\n    terminal_message(\n        message,\n        subject=\"Successfully connected to API\",\n        footer=f\"Status Code: {response.status_code}\",\n    )\n\n@app.command()\ndef login():\n    terminal_message(\"Processing login command\")\n</code></pre> <p>Alright, let's talk through these changes. First, we are creating our own exception class. This is based off of <code>TyperdriveError</code> which itself is a variant of a <code>Buzz</code> exception from <code>py-buzz</code>. By default the <code>@handle_errors()</code> decorator will handle all <code>TyperdriveError</code> exceptions (including descendant exception classes). Instead of hitting your user with an inscrutable stack trace and confusing error message, <code>typerdrive</code> will capture the error and provide a clear explanation for your user.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands_2","title":"Running the commands","text":"<p>Let's try it out:</p> <pre><code>$ typerdrive-tutorial access secured\n\n\u256d\u2500 Failed to access the API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Expected status code 200, but got 401                                      \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>That's much nicer for the user! Notice that the \"subject\" of the message is the string you passed to <code>handle_errors()</code>. The message shown in the box will be the <code>TyperdriveError</code>'s message attribute.</p> <p>This may be much better for the user, but for you as a maintainer it could be very hard to diagnose what went wrong. This time, it's an obvious 401 issue, but if you were getting a 400 here you would probably want to dig into the details a bit more.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-4-add-logging","title":"Step 4: Add Logging","text":"<p>Logging is a great way to capture details about runtime issues. Setting it up isn't necessarily hard, but it does involve some repetetive boilerplate. <code>typerdrive</code> provides a logging feature that makes it very easy to set up logging so that the messages are captured on disk in a sensible place and are easy to access. It even handles log rotation to ensure that a single log file doesn't get too large to manage.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-code_2","title":"Updated code","text":"<p>Let's update the code to enable logging and then talk through the changes:</p> cli.py<pre><code>from enum import StrEnum, auto\n\nimport httpx\nimport typer\nfrom loguru import logger\nfrom typerdrive import (\n    TyperdriveError,\n    add_logs_subcommand,\n    attach_logging,\n    handle_errors,\n    log_error,\n    terminal_message,\n)\n\n\nclass Endpoint(StrEnum):\n    unsecured = auto()\n    secured = auto()\n\n\nclass TutorialError(TyperdriveError):\n    pass\n\n\napp = typer.Typer()\nadd_logs_subcommand(app)\n\n\n@app.command()\n@handle_errors(\"Failed to access the API\", do_except=log_error)\n@attach_logging()\ndef access(ctx: typer.Context, endpoint: Endpoint):\n    logger.debug(f\"Attempting to access api {endpoint=}\")\n    response = httpx.get(f\"http://localhost:8000/{endpoint}\")\n    logger.debug(f\"Got {response.status_code=}\")\n    TutorialError.require_condition(\n        response.status_code == 200,\n        f\"Expected status code 200, but got {response.status_code}\",\n    )\n    message = response.json()[\"message\"]\n    terminal_message(\n        message,\n        subject=\"Successfully connected to API\",\n        footer=f\"Status Code: {response.status_code}\",\n    )\n\n@app.command()\ndef login():\n    terminal_message(\"Processing login command\")\n</code></pre> <p>If you were to run the commands as before, you wouldn't see any effect from these changes. Logs are being captured, though, and <code>typerdrive</code> can help you examine them. First, though, let's discuss the changes.</p> <p>After initializing the Typer app, we invoke the <code>add_logs_subcommand()</code> to add additional commands for managing logs to our app. You can examine them with the <code>--help()</code> flag:</p> <pre><code>$ typerdrive-tutorial --help\n\n Usage: typerdrive-tutorial [OPTIONS] COMMAND [ARGS]...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion          Install completion for the current shell.                 \u2502\n\u2502 --show-completion             Show completion for the current shell, to copy it or      \u2502\n\u2502                               customize the installation.                               \u2502\n\u2502 --help                        Show this message and exit.                               \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 access                                                                                  \u2502\n\u2502 login                                                                                   \u2502\n\u2502 logs     Manage logs for the app                                                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>There we can see the new <code>logs</code> command, and we can dig into that deeper by running it with the <code>--help</code> flag as well:</p> <pre><code>$ typerdrive-tutorial logs --help\n\n Usage: typerdrive-tutorial logs [OPTIONS] COMMAND [ARGS]...\n\n Manage logs for the app\n\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 clear                                                                                   \u2502\n\u2502 show                                                                                    \u2502\n\u2502 audit                                                                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>We'll dig into what these commands do in a moment, but let's return to the code changes.</p> <p>Notice that we added a decorator for our <code>access()</code> command function called <code>@attach_logging()</code>. This enables the logging magic added by <code>typerdrive</code> for the command function it decorates. Additionally, we added a <code>do_except=log_error</code> argument to <code>@handle_errors()</code>. This will log the details of any handled error so we can examine them after the fact. Finally, because <code>loguru</code> is a dependency of <code>typerdrive</code>, we can import it and use it in our function to log our progress.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands_3","title":"Running the commands","text":"<p>Now, let's start checking out those <code>logs</code> commands. First, we'll use the <code>show</code> command to see the current log:</p> <pre><code>$ typerdrive-tutorial logs show\n</code></pre> <p>This will immediately open the current log in your system page. The text it shows will look like this:</p> <pre><code>2025-05-12 12:27:53.050 | DEBUG    | typerdrive.logging.attach:wrapper:42 - Logging\nattached to typer context\n2025-05-12 12:27:53.050 | DEBUG    | typerdrive_tutorial.cli:access:27 - Attempting to\naccess api endpoint=&lt;Endpoint.secured: 'secured'&gt;\n2025-05-12 12:27:53.130 | DEBUG    | typerdrive_tutorial.cli:access:29 - Got\nresponse.status_code=401\n2025-05-12 12:27:53.134 | ERROR    | typerdrive.exceptions:log_error:150 - Failed to access\nthe API -- TutorialError: Expected status code 200, but got 401\n--------\nTraceback:\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.13/site-package\ns/typerdrive/exceptions.py\", line 85, in wrapper\n    return_value = func(*args, **kwargs)\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.13/site-package\ns/typerdrive/logging/attach.py\", line 47, in wrapper\n    return func(ctx, *args, **kwargs)\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/src/typerdrive_tutorial/cli.py\",\nline 30, in access\n    TutorialError.require_condition(\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n        response.status_code == 200,\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        f\"Expected status code 200, but got {response.status_code}\",\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    )\n    ^\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.13/site-package\ns/buzz/base.py\", line 103, in require_condition\n    return require_condition(\n        expr,\n    ...&lt;6 lines&gt;...\n</code></pre> <p>Hey, there's a stack trace like we saw before! Only now, it's hidden from your end user and waiting to be examined through the logs subcommand. Any log lines recorded by <code>loguru</code> will be recorded here; this includes log lines from your app as well as internal logging from <code>typerdrive</code> (as you can see in the first entry).</p> <p>Next, let's take a look at what the <code>audit</code> subcommand does:</p> <pre><code>$ typerdrive-tutorial logs audit\n\n\u256d\u2500 Current log files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502 \ud83d\udcc2 /home/dusktreader/.local/share/typerdrive-tutorial/logs                   \u2502\n\u2502 \u2514\u2500\u2500 \ud83d\udcc4 app.log (2.2 kB)                                                      \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Storing 2.2 kB in 1 files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>You can see that this command shows you both where the logs are stored and how much disk is being used to store them. As I mentioned earlier, <code>typerdrive</code> will automatically rotate (and compress) older log entries. By default, it will rotate the log file once a week. Old log files are kept for a month (by default) before they are automatically removed. Both of these behaviors can be tweaked by adjusting the <code>typerdrive</code> configuration.</p> <p>The final <code>logs</code> sub-command is <code>clear</code>. This command will delete all stored logging data, so use it with care!</p> <p>The <code>Typer.Context</code></p> <p>You may have noticed that the code now includes an extra <code>ctx</code> parameter with type <code>TyperContext</code>. This is a device used by Typer (and <code>Click</code>) to attach additional data to the verequest context. <code>typerdrive</code> also uses it to attach its \"manager\" classes to the context to enable extended behavior. You must include this parameter for <code>typerdrive</code> to work (currently). I'm hoping I can figure out how to make it optional, but haven't arrived at a solution yet.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-5-using-the-typedriveclient","title":"Step 5: Using the <code>TypedriveClient</code>","text":"<p>While things have been working great thus far by using <code>httpx</code> directly, <code>typderdrive</code> provides a customized client (based on httpx) that has some nice extended functionality.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-code_3","title":"Updated code","text":"<p>Let's switch the code over to use this <code>TyperdriveClient</code> instead of <code>httpx</code> and then talk through the changes:</p> cli.py<pre><code>from enum import StrEnum, auto\nfrom typing import cast\n\nimport typer\nfrom loguru import logger\nfrom pydantic import BaseModel\nfrom typerdrive import (\n    TyperdriveClient,\n    TyperdriveError,\n    add_logs_subcommand,\n    attach_client,\n    attach_logging,\n    handle_errors,\n    log_error,\n    terminal_message,\n)\n\n\nclass Endpoint(StrEnum):\n    unsecured = auto()\n    secured = auto()\n\n\nclass TutorialError(TyperdriveError):\n    pass\n\n\nclass APIResponse(BaseModel):\n    message: str\n\n\napp = typer.Typer()\nadd_logs_subcommand(app)\n\n\n@app.command()\n@handle_errors(\"Failed to access the API\", do_except=log_error)\n@attach_logging()\n@attach_client(api=\"http://localhost:8000\")\ndef access(ctx: typer.Context, endpoint: Endpoint, api: TyperdriveClient):\n    logger.debug(f\"Attempting to access api {endpoint=}\")\n    response = cast(\n        APIResponse,\n        api.get_x(\n            endpoint,\n            expected_status=200,\n            response_model=APIResponse,\n        ),\n    )\n    terminal_message(\n        response.message,\n        subject=\"Successfully connected to API\",\n    )\n\n@app.command()\ndef login():\n    terminal_message(\"Processing login command\")\n</code></pre> <p>The first thing to note here is that we have created a new Pydantic model that will be used to capture the data returned from the API. In the case of the <code>unsecured</code> endpoint, the data returned is not very complex at all. When you are working with real, production APIs, though, the schema of responses can get quite complicated. It is really useful to be able to deserialize a large JSON blob into Pydantic objects and validate the data at the same time. You'll see a little more complex example of using a Pydantic model to extract an API response when we implement the <code>login</code> method.</p> <p>Next, you should notice that we are getting an instance of a <code>TyperdriveClient</code> as a parameter to our <code>access()</code> command function through the <code>@attach_client()</code> decorator. By providing a keyword argument we are doing two things at once:</p> <ul> <li>Establishing a <code>base_url</code> for the new client</li> <li>Providing the name of the client that will be matched to a parameter of the <code>access()</code> command function.</li> </ul> <p>To get access to a <code>TyperdriveClient</code> in this way, you need to provide an argument to your command function with the type <code>TyperdriveClient</code> and name that matches one provided in <code>@attach_client()</code></p> <p>Because we've supplied a <code>base_url</code> for the client, we can give just the URL path after the base for our request. In this case it is just whichever endpoint we select with the <code>endpoint</code> parameter.</p> <p>By providing an <code>expected_status</code> argument, we are instructing the <code>TyperdriveClient</code> to only accept responses with that exact status code. If any other code is receeved, a <code>ClientError</code> (derived from <code>TyperdriveError</code>) will be raised. Our error handling will catch such an error and give a polite response to the user.</p> <p>Finally, the <code>get_x()</code> method will deserialize the response data into an instance of the <code>response_model</code> we provided. Although the explicit <code>cast()</code> we use here is not necessary for things to work, it helps static type checkers understand that the value returned from the function will be an instance of <code>APIRespnose</code>.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands_4","title":"Running the commands","text":"<p>OK, let's try it out:</p> <pre><code>$ typerdrive-tutorial access unsecured\n\n\u256d\u2500 Successfully connected to API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Accessed unsecured endpoint!                                               \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>No surprises here. The request was successful, and we access the message through the <code>response</code> object.</p> <p>Now, let's hit the <code>secured</code> endpoint:</p> <pre><code>\u256d\u2500 Failed to access the API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Got an unexpected status code: Expected 200, got 401 -- Unauthorized       \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>This time, the message is a bit different. Because the status code didn't match, we get an error message that explains the situation nicely. If we peek at the logs (with <code>logs show</code>), we'll see some extra info logged by the client:</p> <pre><code>2025-05-12 13:22:30.554 | DEBUG    | typerdrive_tutorial.cli:access:42 - Attempting to\naccess api endpoint=&lt;Endpoint.secured: 'secured'&gt;\n2025-05-12 13:22:30.554 | DEBUG    | typerdrive.client.base:request_x:26 - Processing GET\nrequest to http://localhost:8000/secured\n2025-05-12 13:22:30.554 | DEBUG    | typerdrive.client.base:request_x:53 - Issuing request\n2025-05-12 13:22:31.212 | DEBUG    | typerdrive.client.base:request_x:57 - Checking\nresponse for expected_status=200\n2025-05-12 13:22:31.213 | ERROR    | typerdrive.exceptions:log_error:150 - Failed to access\nthe API -- ClientError: Got an unexpected status code: Expected 200, got 401 --\nUnauthorized\n--------\nTraceback:\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.13/site-package\ns/typerdrive/exceptions.py\", line 85, in wrapper\n    return_value = func(*args, **kwargs)\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.13/site-package\ns/typerdrive/logging/attach.py\", line 47, in wrapper\n    return func(ctx, *args, **kwargs)\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/.venv/lib/python3.13/site-package\ns/typerdrive/client/attach.py\", line 76, in wrapper\n    return func(ctx, *args, **kwargs)\n  File\n\"/home/dusktreader/git-repos/personal/typerdrive-tutorial/src/typerdrive_tutorial/cli.py\",\nline 45, in access\n    api.get_x(\n    ~~~~~~~~~^\n...\n</code></pre>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-6-adding-app-settings","title":"Step 6: Adding app settings","text":"<p>In the building stages of a new CLI app, you often don't begin development by connecting to the same API URL that your app access in production. There may also be other ways that the URL for the API may differ throughout the lifetime of your CLI such as region, subdomain, API versions, etc. Thus, it's usually not the best idea to have the API URL hard-coded in your app. To allow for runtime configuration of your app for this and other purposes, <code>typerdrive</code> provides a settings management feature to set, adjust, and view settings values within the CLI itself.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-code_4","title":"Updated code","text":"<p>Let's see how we can add this functionality into our app and then we'll talk through the changes:</p> cli.py<pre><code>from enum import StrEnum, auto\nfrom typing import cast\n\nimport typer\nfrom loguru import logger\nfrom pydantic import BaseModel\nfrom typerdrive import (\n    TyperdriveClient,\n    TyperdriveError,\n    add_logs_subcommand,\n    add_settings_subcommand,\n    attach_client,\n    attach_logging,\n    attach_settings,\n    handle_errors,\n    log_error,\n    terminal_message,\n)\n\n\nclass Endpoint(StrEnum):\n    unsecured = auto()\n    secured = auto()\n\n\nclass Environment(StrEnum):\n    dev = auto()\n    prod = auto()\n\n\nclass TutorialError(TyperdriveError):\n    pass\n\n\nclass APIResponse(BaseModel):\n    message: str\n\n\nclass Settings(BaseModel):\n    api_url: str\n    env: Environment\n\n\napp = typer.Typer()\nadd_logs_subcommand(app)\nadd_settings_subcommand(app, Settings)\n\n\n@app.command()\n@handle_errors(\"Failed to access the API\", do_except=log_error)\n@attach_logging()\n@attach_settings(Settings)\n@attach_client(api=\"api_url\")\ndef access(ctx: typer.Context, endpoint: Endpoint, api: TyperdriveClient, settings: Settings):\n    logger.debug(f\"Attempting to access api {endpoint=} in {settings.env} environment\")\n    response = cast(\n        APIResponse,\n        api.get_x(\n            endpoint,\n            expected_status=200,\n            response_model=APIResponse,\n        ),\n    )\n    terminal_message(\n        response.message,\n        subject=\"Successfully connected to API\",\n    )\n\n@app.command()\ndef login():\n    terminal_message(\"Processing login command\")\n</code></pre> <p>Here you can see that we've defined a <code>Settings</code> Pydantic model that will be used to define the settings that our CLI app needs. The model will also be used to validate the settings values that users will provide. Additionally, we defined an <code>Environment</code> enum to let us define which environment our CLI is working in.</p> <p>Next, we use the <code>add_settings_subcommand</code> function to add sub-commands to set, update, and manipulate the app settings. We'll take a look at those commands shortly.</p> <p>Finally, for the <code>access()</code> command function itself, we are going to attach the app settings using the <code>@attach_settings()</code> decorator. This allows us to specify a parameter of type <code>Settings</code> (this must match the settings model class that was attached) to get access to the settings in the function body. We then updated the first log line to reflect the settings.</p> <p>It's also notable that the value passed to <code>@attach_client()</code> for the <code>api</code> parameter was changed. <code>typerdrive</code> will first try to find a key in the app settings to use as the <code>base_url</code> for the client. This requires that the settings are already attached, so the <code>@attach_settings()</code> decorator must come first.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands_5","title":"Running the commands","text":"<p>Let's run the <code>access</code> command as-is and see what happens:</p> <pre><code>$ typerdrive-tutorial access unsecured\n\n\u256d\u2500 Failed to access the API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Initial settings are invalid: {'api_url': 'Field required', 'env':         \u2502\n\u2502 'Field required'}                                                            \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>This is actually what you should see because we haven't actually defined any values for our settings, and we must have a value for the <code>api_url</code>.</p> <p>It's time to dig into the settings commands to resolve this. You can see the available commands with the <code>--help</code> flag:</p> <pre><code>$ typerdrive-tutorial settings --help\n\n Usage: typerdrive-tutorial settings [OPTIONS] COMMAND [ARGS]...\n\n Manage settings for the app\n\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 bind                                                                         \u2502\n\u2502 update                                                                       \u2502\n\u2502 unset                                                                        \u2502\n\u2502 reset                                                                        \u2502\n\u2502 show                                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>First, let's view the current settings. For this, we will use the <code>show</code> sub-command:</p> <pre><code>$ typerdrive-tutorial settings show\n\n\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   api-url -&gt; &lt;UNSET&gt;                                                         \u2502\n\u2502       env -&gt; &lt;UNSET&gt;                                                         \u2502\n\u2502                                                                              \u2502\n\u2502   Settings are invalid:                                                      \u2502\n\u2502   api-url -&gt; Field required                                                  \u2502\n\u2502       env -&gt; Field required                                                  \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Before we can attach the settings to our command without error, we need to provide some values for these required settings. To do that, let's use the <code>bind</code> sub-command. Before we issue the command, let's check how it works with <code>--help</code>:</p> <pre><code>$ typerdrive-tutorial settings bind --help\n\n Usage: typerdrive-tutorial settings bind [OPTIONS]\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --api-url        TEXT        [default: None] [required]                   \u2502\n\u2502 *  --env            [dev|prod]  [default: None] [required]                   \u2502\n\u2502    --help                       Show this message and exit.                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>kebab-case and snake_case</p> <p>At this point, a detail needs to be pointed out. Notice that the settings here appear in kebab-case even though in the code they are defined with snake_case. This is due to how <code>Typer</code> coerces function arguments into CLI options which are usually kebab-case. This is a little gotcha that you might need to watch out for!</p> <p>Let's go ahead and define our settings using the <code>bind</code> command:</p> <pre><code>$ typerdrive-tutorial settings bind --api-url=http://localhost:8000 --env=dev\n\n\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   api-url -&gt; http://localhost:8000                                           \u2502\n\u2502       env -&gt; dev                                                             \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 saved to /home/dusktreader/.local/share/typerdrive-tutorial/settings.json \u2500\u2500\u256f\n</code></pre> <p>Now our settings are valid! Let's go ahead and try the <code>access</code> command again to make sure that our app will use the settings we expect:</p> <pre><code>$ typerdrive-tutorial access unsecured\n\n\u256d\u2500 Successfully connected to API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Accessed unsecured endpoint!                                               \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Everything is working! Let's move on to the next <code>typerdrive</code> feature.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#step-7-using-the-cache","title":"Step 7: Using the Cache","text":"<p>When you're making a CLI that needs to authenticate, you really need to have some way to hang on to the auth token you are issued between commands so that you don't have to log in every single time you run your CLI app. This is where the cache comes in. <code>typerdrive</code> provides a <code>CacheManager</code> that can store and retrieve data from the cache. It also stores the data in a sensible location, and gives you the ability to check what's stored in the cache as well as clear it out if you need to.</p> <p>After all the changes we've made, we still can't access the <code>/secured</code> endpoint. In order to get access to that secured output we need to log in to our OIDC service, secure a token, and use it in subsequent requests to the secured endpoint. Let's update the code to allow login and secured access.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-code_5","title":"Updated code","text":"<p>This change introduces much more code, but it's really not that complicated. I'll walk you through it after I show you the code. The source code for <code>cli.py</code> now looks like this:</p> cli.py<pre><code>from enum import StrEnum, auto\nfrom time import sleep\nfrom typing import cast\n\nimport typer\nfrom loguru import logger\nfrom pydantic import BaseModel\nfrom typerdrive import (\n    CacheManager,\n    TyperdriveClient,\n    TyperdriveError,\n    add_cache_subcommand,\n    add_logs_subcommand,\n    add_settings_subcommand,\n    attach_cache,\n    attach_client,\n    attach_logging,\n    attach_settings,\n    handle_errors,\n    log_error,\n    terminal_message,\n)\n\n\nclass Endpoint(StrEnum):\n    unsecured = auto()\n    secured = auto()\n\n\nclass Environment(StrEnum):\n    dev = auto()\n    prod = auto()\n\n\nclass TutorialError(TyperdriveError):\n    pass\n\n\nclass APIResponse(BaseModel):\n    message: str\n\n\nclass Settings(BaseModel):\n    api_url: str\n    env: Environment\n    auth_url: str\n    client_id: str\n    audience: str\n\n\napp = typer.Typer()\nadd_logs_subcommand(app)\nadd_settings_subcommand(app, Settings)\nadd_cache_subcommand(app)\n\n\n@app.command()\n@handle_errors(\"Failed to access the API\", do_except=log_error)\n@attach_logging()\n@attach_settings(Settings)\n@attach_client(api=\"api_url\")\n@attach_cache()\ndef access(ctx: typer.Context, endpoint: Endpoint, api: TyperdriveClient, settings: Settings, cache: CacheManager):\n    logger.debug(f\"Attempting to access api {endpoint=} in {settings.env} environment\")\n    headers = {}\n    if endpoint == Endpoint.secured:\n        logger.debug(\"Loading access token from cache\")\n        access_token: str = cache.load_text(\"auth/access.token\")\n        headers = {\"Authorization\": f\"Bearer {access_token}\"}\n    response = cast(\n        APIResponse,\n        api.get_x(\n            endpoint,\n            expected_status=200,\n            response_model=APIResponse,\n            headers=headers,\n        ),\n    )\n    terminal_message(\n        response.message,\n        subject=\"Successfully connected to API\",\n    )\n\n\nclass LoginRequestData(BaseModel):\n    client_id: str\n    grant_type: str\n    audience: str\n\n\nclass TokenRequestData(BaseModel):\n    grant_type: str\n    device_code: str\n    client_id: str\n\n\nclass DeviceCodeData(BaseModel):\n    device_code: str\n    verification_uri_complete: str\n    interval: int\n\n\n@app.command()\n@handle_errors(\"Login failed\")\n@attach_logging()\n@attach_settings(Settings)\n@attach_cache()\n@attach_client(auth=\"auth_url\")\ndef login(ctx: typer.Context, settings: Settings, auth: TyperdriveClient, cache: CacheManager):\n    logger.debug(\"Starting login process\")\n    logger.debug(\"Requesting device code from auth provider\")\n    device_code_data = cast(\n        DeviceCodeData,\n        auth.post_x(\n            \"/oauth/device/code\",\n            expected_status=200,\n            body_obj=LoginRequestData(\n                client_id=settings.client_id,\n                grant_type=\"client_credentials\",\n                audience=settings.audience,\n            ),\n            response_model=DeviceCodeData,\n        ),\n    )\n    terminal_message(\n        f\"Open {device_code_data.verification_uri_complete} in a browser to complete login\",\n        subject=\"Complete login with browser\",\n    )\n    while True:\n        logger.debug(\"Attempting to retrieve a token\")\n        response_data = cast(\n            dict[str, str],\n            auth.post_x(\n                \"/oauth/token\",\n                body_obj=TokenRequestData(\n                    grant_type=\"urn:ietf:params:oauth:grant-type:device_code\",\n                    device_code=device_code_data.device_code,\n                    client_id=settings.client_id,\n                ),\n            ),\n        )\n        if \"error\" in response_data:\n            TutorialError.require_condition(\n                response_data[\"error\"] == \"authorization_pending\",\n                f\"Failed to fetch a token with device_code {device_code_data.device_code}\",\n            )\n            logger.debug(f\"Didn't get a token yet. Trying again in {device_code_data.interval} seconds\")\n            sleep(device_code_data.interval)\n        else:\n            with TutorialError.handle_errors(\"Couldn't extract token from response\"):\n                access_token = response_data[\"access_token\"]\n            logger.debug(f\"Received access token {access_token[:32]}...\")\n            cache.store_text(access_token, \"auth/access.token\")\n            break\n    terminal_message(\"Successfully logged in!\", subject=\"Login successful\")\n</code></pre> <p>Let's start with the simple changes before we dive into the internals of the new, improved <code>login</code> function.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#updated-settings","title":"Updated <code>Settings</code>","text":"<p>First, we need to add some additional items to our <code>Settings</code> model. The <code>auth_url</code> will be the <code>base_url</code> for the Auth0 API. The <code>client_id</code> will be the unique ID we got while setting up Armasec with Auth0. The <code>audience</code> will also come from the Auth0/Armasec setup. Let's go ahead and bind the values we need to our app's settings. Because we've already provided some settings that we want to keep, we'll use the <code>update</code> sub-command instead of the <code>bind</code> sub-command:</p> <pre><code>$ typerdrive-tutorial settings update \\\n  --auth-url=https://typerdrive-tutorial.us.auth0.com \\\n  --client-id=ahU6---------------------------- \\\n  --audience=typerdrive-tutorial\n\n\u256d\u2500 Current settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                                                         \u2502\n\u2502     api-url -&gt; http://localhost:8000                                                                    \u2502\n\u2502         env -&gt; dev                                                                                      \u2502\n\u2502    auth-url -&gt; https://typerdrive-tutorial.us.auth0.com                                                 \u2502\n\u2502   client-id -&gt; ahU6----------------------------                                                         \u2502\n\u2502    audience -&gt; typerdrive-tutorial                                                                      \u2502\n\u2502                                                                                                         \u2502\n\u2570\u2500 saved to /home/dusktreader/.local/share/typerdrive-tutorial/settings.json \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#new-cache-sub-commands","title":"New <code>cache</code> sub-commands","text":"<p>Next, note that in the revised code, we're calling the <code>add_cache_subcommand()</code> function. This will add some commands to our CLI that allow us to show the state of the cache and to clear it out if we need to:</p> <pre><code>$ typerdrive-tutorial cache --help\n\n Usage: typerdrive-tutorial cache [OPTIONS] COMMAND [ARGS]...\n\n Manage cache for the app\n\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 clear                                                                        \u2502\n\u2502 show                                                                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#data-models","title":"Data models","text":"<p>Our communication with the Auth0 API involves three specific structures, and we've defined three Pydantic classes to capture this. The <code>DeviceCodeRequest</code> model describes the data we need to send when requesting a login. The <code>DeviceCodeResponse</code> model describes that data that will be returned by Auth0 once it's validated our request for a code. Finally, The <code>TokenRequestData</code> describes the data we need to send to request an auth token after we've logged in. <code>typerdrive</code> allows us to provide these models to our API requests to allow for easy serialization and deserialization as well as validation that the values are correct.</p> <p>As with the other features, there is an <code>@attach_cache()</code> decorator that binds the cache to the command context. Again, we get access to the cache through a function argument of type <code>CacheManager</code>. The <code>CacheManager</code> provides methods to store and retrieve data in the cache.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#the-new-login-function","title":"The new <code>login()</code> function","text":"<p>Before we review the changes in the <code>access()</code> command function, let's go through the internals of the new <code>login()</code> command function to see how we secure an auth token.</p> <p>At a high level, the function does the following:</p> <ol> <li>Request a device code from Auth0</li> <li>Show a link to the user with the code embedded in it</li> <li>Wait for the user to complete the login process</li> <li>Retrieve the auth token from the API</li> <li>Store it in the cache.</li> </ol> <p>Let's dig in a bit on each of those parts.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#1-requesting-a-device-code","title":"1. Requesting a device code","text":"<p>This is the code that fetches the device code:</p> <pre><code>    device_code_data = cast(\n        DeviceCodeResponse,\n        auth.post_x(\n            \"/oauth/device/code\",\n            expected_status=200,\n            body_obj=DeviceCodeRequest(\n                client_id=settings.client_id,\n                grant_type=\"client_credentials\",\n                audience=settings.audience,\n            ),\n            response_model=DeviceCodeResponse,\n        ),\n    )\n</code></pre> <p>To get a device code from Auth0, we are posting a request to the <code>/oauth/device/code</code> endpoint and providing the app's <code>client_id</code> and <code>audience</code>. We get those from the settings that we bound to the app. We will always use the <code>grant_type=\"client_credentials\"</code>, so that can be hard-coded. We are also taking advantage of the <code>TyperdriveClient</code>'s ability to use a Pydantic model instance to provide the <code>POST</code> body here by passing a <code>DeviceCodeRequest</code> instance to the <code>body_obj</code> parameter. Finally, we provide <code>DeviceCodeResponse</code> as the <code>response_model</code> for the <code>TyperdriveClient</code> to unpack the response data into.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#2-showing-the-user-a-login-link","title":"2. Showing the user a login link","text":"<pre><code>    terminal_message(\n        f\"Open {device_code_data.verification_uri_complete} in a browser to complete login\",\n        subject=\"Complete login with browser\",\n    )\n</code></pre> <p>Because the response provided a verification URI for us, we can just show a terminal message to the user containing that. The URI will contain the device code that we received from the first request. Most modern terminals allow you to click on a link to open it in a browser. For mine, I just have to hold <code>ctrl</code> and click the link.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#3-5-wait-for-login-retrieve-auth-token-store-it-in-the-cache","title":"3-5. Wait for login, retrieve auth token, store it in the cache","text":"<p>The next 3 steps are wrapped up in the final bit of code:</p> <pre><code>    while True:\n        logger.debug(\"Attempting to retrieve a token\")\n        response_data = cast(\n            dict[str, str],\n            auth.post_x(\n                \"/oauth/token\",\n                body_obj=TokenRequest(\n                    grant_type=\"urn:ietf:params:oauth:grant-type:device_code\",\n                    device_code=device_code_data.device_code,\n                    client_id=settings.client_id,\n                ),\n            ),\n        )\n        if \"error\" in response_data:\n            TutorialError.require_condition(\n                response_data[\"error\"] == \"authorization_pending\",\n                f\"Failed to fetch a token with device_code {device_code_data.device_code}\",\n            )\n            logger.debug(f\"Didn't get a token yet. Trying again in {device_code_data.interval} seconds\")\n            sleep(device_code_data.interval)\n        else:\n            with TutorialError.handle_errors(\"Couldn't extract token from response\"):\n                access_token = response_data[\"access_token\"]\n            logger.debug(f\"Received access token {access_token[:32]}...\")\n            cache_manager.store_text(access_token, \"auth/access.token\")\n            break\n</code></pre> <p>For this walkthrough, we're going to loop forever until a user completes the login process. For a real app, you probably want the process to time out after some period of time. However, to keep things as simple as possible, we will just wait forever.</p> <p>We check to see if the user has logged in yet by requesting an access token from the Auth0 api at the <code>/oath/token</code> endpoint. Again, we hard-code the <code>grant_type</code> and provide the <code>client_id</code> we configured in the app settings. The last piece provided is the <code>device_code</code> we received in the first request.</p> <p>This time, though, we do not provide a <code>response_model</code> or an expected status because we need to check the error data if the API returns a non 200 status. Instead, the <code>post_x()</code> function will return a plain dictionary which we can pull the <code>error</code> from. If this error is exactly \"authorization_pending\", then we know that the user hasn't yet completed the login process but the login didn't fail either. If we see that specific error, we are just going to wait for a period and try again. Helpfully, Auth0 (and any other OIDC provider) will provide an <code>interval</code> of time that we should wait before requesting the auth token again to avoid flooding the API.</p> <p>Finally, if we don't get an error response, it means the user has completed the login process. We can then extract the the <code>access_token</code> from the response and store it in our cache. We use the cache key <code>auth/access.token</code>; we will retrieve the token using this cache key when we need to access a secured endpoint.</p> <p>Let's use one of our new <code>cache</code> sub-commands to see what our cache looks like now:</p> <pre><code>\u256d\u2500 Current cache \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502 \ud83d\udcc2 /home/dusktreader/.cache/typerdrive-tutorial                              \u2502\n\u2502 \u2514\u2500\u2500 \ud83d\udcc2 auth                                                                  \u2502\n\u2502     \u2514\u2500\u2500 \ud83d\udcc4 access.token (684 Bytes)                                          \u2502\n\u2502                                                                              \u2502\n\u2570\u2500 Storing 684 Bytes in 1 files \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>As you can see, we now have our access token stored in our cache for future use.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#accessing-the-secured-endpoint","title":"Accessing the secured endpoint","text":"<p>Now that we've seen how we get the access token and store it in the cache, let's check out how to use it to access the secured endpoint.</p> <pre><code>    headers = {}\n    if endpoint == Endpoint.secured:\n        logger.debug(\"Loading access token from cache\")\n        access_token = cache.load_text(\"auth/access.token\")\n        headers = {\"Authorization\": f\"Bearer {access_token}\"}\n</code></pre> <p>First, we will check if the user has requested to access the <code>secured</code> endpoint. If so, we retrieve the <code>access_token</code> from our cache and add it into an <code>Authorization</code> header as a Bearer token.</p> <p>Once that's done, we can finally access our secured endpoint. Let's try it out!</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#running-the-commands_6","title":"Running the commands","text":"<p>First, we need to log in using the <code>login</code> subcommand. When I open the link in my browser, I'm able to log in using my google account. When I'm finished, the CLI lets me know I was successful:</p> <pre><code>$ typerdrive-tutorial login\n\n\u256d\u2500 Complete login with browser \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Open https://typerdrive-tutorial.us.auth0.com/activate?user_code=PLTZ-LXGC \u2502\n\u2502 in a browser to complete login                                               \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n\n\u256d\u2500 Login successful \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Successfully logged in!                                                    \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>In my browser, the login windows look like this:</p> <p></p> <p>Now, let's see if we can access that <code>secured</code> endpoint:</p> <pre><code>$ typerdrive-tutorial access secured\n\n\u256d\u2500 Successfully connected to API \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                                              \u2502\n\u2502   Accessed secured endpoint!                                                 \u2502\n\u2502                                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>And there it is! We've successfully built up a CLI that can log into an OIDC auth provider, cache the access token, and then access secured endpoints!</p> <p>Now, it's worth mentioning that most CLIs of this type will also need to manage refresh tokens so that you don't have to re-login every time your access token expires. However, that's an exercise I'm going to leave to the reader because this walkthrough is already pretty long. The good news is that you can use the cache for the refresh token as well.</p>","tags":["Python,Typer"]},{"location":"2025/05/13/introducing-typerdrive-develop-api-connected-typer-apps-at-lightspeed/#conclusion","title":"Conclusion","text":"<p>While the example app we built here doesn't do a whole lot, it does tap into some really useful functionality provided by <code>typerdrive</code>. The <code>typerdrive</code> package was designed from the ground up to make building CLIs that connect to secured APIs easy and fun. The big idea is to let you get to the business of building out your business logic sooner rather than setting up all the scaffolding needed for these type of CLIs.</p> <p>I've gathered the patterns I've used to build these type of applications into a re-usable package that's friendly to both the developer and to the end user. I hope you'll try out <code>typerdrive</code> and let me know what you think of it.</p> <p>As always, feedback is very welcome as are Github issues and pull-requests.</p> <p>Check out the <code>typerdrive</code> Github repo and give the live demo a try as well.</p> <p>Thanks for reading!</p>","tags":["Python,Typer"]},{"location":"archive/2025/","title":"2025","text":""},{"location":"category/dev/","title":"dev","text":""}]}