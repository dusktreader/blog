{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Posts","text":"<p>Tech learnings and musings from the.dusktreader.</p> <p>Open to work</p> <p>I'm looking for a job right now! If you know of any openings that match my skill-set, please let me know! You can read my resume over at my cv site. Thanks!</p> <p>the.dusktreader blog \u00a9 2025 by Tucker Beck is licensed under CC BY-SA 4.0</p>"},{"location":"2025/03/29/self-contained-python-scripts-with-uv/","title":"Self-contained Python scripts with <code>uv</code>","text":"<p>TLDR</p> <p>You can add uv into the shebang line for a Python script to make it a self-contained executable.</p> <p>I am working on a Go project to better learn the language. It's a simple API backed by a postgres database.</p> <p>When I need to test out an endpoint, I prefer to use the httpx python package inside an ipython REPL over making curl requests. It's nice to be able to introspect responses and easily package payloads with dicts instead of writing out JSON.</p> <p>Anyway, I decided to write a script to upsert some user data so that I can beat on my <code>/users</code> endpoint.</p> <p>My <code>jam_users.py</code> script looks like this:</p> <pre><code>import httpx\nimport IPython\nfrom loguru import logger\n\nusers = [\n    dict(name=\"The Dude\", email=\"the.dude@abides.com\", password=\"thedudeabides\"),\n    dict(name=\"Walter Sobchak\", email=\"walter@sobchak-security.com\", password=\"vietnamvet\"),\n    dict(name=\"Donnie\", email=\"donniesurfs@yahoo.com\", password=\"iamthewalrus\"),\n    dict(name=\"Maude\", email=\"mauddie@avant-guard.com\", password=\"goodmanandthorough\"),\n]\n\nr = httpx.get(\"http://localhost:4000/v1/users\")\nr.raise_for_status()\n\nfor user in r.json()[\"users\"]:\n    logger.info(f\"Deleting: {user['name']}\")\n    r = httpx.delete(f\"http://localhost:4000/v1/users/{user['id']}\")\n    r.raise_for_status()\n\nfor user in users:\n    r = httpx.post(\"http://localhost:4000/v1/users\", json=user)\n    r.raise_for_status()\n    logger.info(f\"Created: {r.json()}\")\n\nIPython.embed()\n</code></pre> <p>This is really straight-forward. It will clear out any existing users and then insert these test users. Right after that, I get dropped into an <code>ipython</code> repl to do what I need for testing. All I have to do is run:</p> <pre><code>python jam_users.py\n</code></pre> <p>However, if I want to run the script as-is, I will need to choose one of these approaches:</p> <ul> <li>Install the dependencies <code>httpx</code>, <code>IPython</code>, and <code>loguru</code> globally in my system python</li> <li>Create a virtual environment, activate it, install deps, and run my script while the venv is activated</li> </ul> <p>These are both not great options in my opinion. These approaches also rely on having a system python installed that is compatible with these packages. This isn't as big of a problem, but something to consider anyway.</p> <p>I've been using uv a lot lately, and I'm becoming quite enamoured with its usefulness as a package manager, efficiency as a pip replacement, and abilities for isolated python executables. One thing that I haven't used much yet are the special <code># /// script</code> tags in a python script.</p> <p>When I first read about this functionality, I was pretty skeptical. I'm not particularly keen on embedding syntax into comments. However, this seemed like the perfect application. So, updated my script to include the deps in the script header like so:</p> <pre><code># /// script\n# dependencies = [\"ipython\", \"httpx\", \"loguru\"]\n# ///\nimport httpx\nimport IPython\nfrom loguru import logger\n\n...\n</code></pre> <p>With this added, now I can run the script really easily with <code>uv</code>:</p> <pre><code>uv run jam_users.py\n</code></pre> <p>Great! Now, <code>uv</code> will create an isolated virtual environment for the script, download the dependencies and install them, and then run my script in the context of that venv! I don't have to manage the virtual environment myself nor worry about cluttering my system python with packages that I will invariably forget to remove later.</p> <p>One nice thing about a regular Python script, though, is that you can make it executable with a shebang line:</p> <pre><code>#!/usr/bin/env python\n...\n</code></pre> <p>Now, if I make the script executable (<code>chmod +x jam_users.py</code>), I can invoke it directly as an executable script! However, this won't take advantage of the <code>uv</code> script header because Python itself will just ignore the comment.</p> <p>So, I did some digging and found out that you can actually embed the invocation of the uv command right in the shebang line like so:</p> <pre><code>#!/usr/bin/env -S uv run --script\n# /// script\n# dependencies = [\"ipython\", \"httpx\", \"loguru\"]\n# ///\nimport httpx\nimport IPython\nfrom loguru import logger\n\n...\n</code></pre> <p>This works because the <code>-S</code> flag tells the system to split everything after it into separate arguments before passing it to the system's <code>env</code>.</p> <p>Now (after <code>chmod +x jam_users.py</code>, of course), I can execute my script directly:</p> <pre><code>./jam_users.py\n</code></pre> <p>That's it! What's even better is that I can run this script on any (Unix) system that has <code>uv</code> installed without needing to do ANY dependency or virtual environment management.</p> <p>Now, this script itself is really trivial and not much more than a toy example. However, in my past I have written rather complex scripts that I needed to hand off to other users to run. Of course, this always came with a long explanation of how to prepare their system just to run the script. This approach solves that problem instantly and painlessly (as long as they have <code>uv</code> installed).</p> <p>Take it for a spin, and let me know your thoughts.</p> <p>Thanks for reading!</p>","tags":["Python","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/","title":"Bootstrapping Python projects with <code>copier</code>","text":"<p>TLDR</p> <p>I used <code>copier</code> to create a python project template that includes logic to deploy the project to GitHub.</p> <p>I tend to create a lot of Python projects of various sizes. In the past few weeks, this has been even more frequent. Just a few days ago, I started a new project called drivel. It is a CLI and Python package that generates fun metasyntactic names (think <code>foo</code>, <code>bar</code>, <code>baz</code>) to use in my code. You can read more about it in the drivel docs if you want to learn more.</p> <p>When I went to start this project, I did what I usually do. I copied one of my other projects to a new directory and started ripping stuff out, renaming things, and just generally futzing around until I had the scaffolding for my new project. This isn't hard work, but it always ends up taking a lot longer than I expect.</p> <p>There are a lot of conventions that I've gotten attached to in my projects over the years. And, while it's not that hard to just borrow things from past projects, it's boring work that cries out to be automated.</p> <p>So, I decided to create a project template that would allow me to do all this in just a matter of seconds.</p> <p>Open to work</p> <p>I'm looking for a job right now! If you know of any openings that match my skill-set, please let me know! You can read my resume over at my cv site. Thanks!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#a-case-study","title":"A case study","text":"<p>As I go through this article, I'm going to use an imaginary project as a case study. I'm calling it <code>space-monkey</code>, because it's all about doing an exploratory trial run. Just like the monkeys and apes that were sent into orbit before humans, this project will be used to explore and test my project template.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#the-boring-stuff","title":"The boring stuff","text":"<p>Before I get into how I actually built out the template, I want to take some time going over the reasons why the projects I produce from this template are the way they are. To do that, I need to go over my personal philosophy for setting up Python projects. This might not be that interesting to you. If so, feel free to skip ahead to the fun stuff.</p> <p>There are some basic essentials that I like to have in my Python projects. These come in three flavors:</p> <ol> <li>Baseline requirements for a good project</li> <li>Ergonomics to make the project nice to work on</li> <li>Processes to make the project ready to go</li> </ol> <p>Let's look at each one in a little detail.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#baseline-requirements","title":"Baseline requirements","text":"<p>I am kind of a stickler for a few baseline requirements that I have for my projects. Even for small projects, I like to make sure that requirements are met so I don't feel...icky working in my own code.</p> <p>Here are the requirements that I've settled on over the years of writing Python projects:</p> <ul> <li>A decent <code>README.md</code></li> <li>A <code>LICENSE.md</code> file</li> <li>A <code>CHANGELOG.md</code></li> <li>A <code>pyproject.toml</code></li> <li>Good project structure</li> <li>Docs</li> </ul> <p>Each one of these requirements is born of past experiences working on Python projects. Along the way, I've learned some best practices and definitely developed some rather opinionated preferences for each. As I walk through these, please keep in mind that these are my opinions and preferences for my own projects. I don't think it's gospel; it's just what I like.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#readmemd","title":"<code>README.md</code>","text":"<p>I've become convinced  that Markdown is the best format for writing documentation at every level. I used to be pretty attached to reStructuredText (or RST), and it is a very powerful spec for writing technical documentation. But it has some serious drawbacks. For one, the syntax is far more esoteric. Also, working with the Sphinx documentation engine is not very fun. Overall, Markdown is just better. It doesn't come out-of-the-box with all the powerful features available with Sphinx and reStructuredText, but I've found that using Markdown with the extensions provided by mkdocs-material provides what I need and makes producing nice looking documentation a breeze.</p> <p>So, I usually start with a <code>README.md</code> with a few essential elements:</p> <ul> <li>A project summary</li> <li>A \"Super-quick start\" section that briefly explains how to install the project.</li> <li>For a CLI or similar tool, a brief demonstration of how to run it</li> <li>A link to the documentation page</li> </ul> <p>That's pretty much it. For smaller projects, I've leaned on the README to document the whole project. However, with mkdocs-material and GitHub Pages, it's so easy to stand up a docs site that I usually do that for even small projects.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#licensemd","title":"<code>LICENSE.md</code>","text":"<p>For any project that you are going to host on a public GitHub repository, you need to have a software license. The GitHub docs offer a good explanation:</p> <p>without a license, the default copyright laws apply, meaning that you retain all rights to your source code and no one may reproduce, distribute, or create derivative works from your work.</p> <p>Another good reason to have a license is to make sure that you can't be held liable for misuse of your software or its failure in any situation.</p> <p>As a rule, I prefer a very permissive license and use the MIT License</p> <p>But, why make it a Markdown file and not not just <code>LICENSE</code> without an extension? Well, I usually use just a little bit of markup in the file. More importantly, though, it signals to the OS and users that the file contains text and should be opened with a text viewer/editor.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#changelogmd","title":"<code>CHANGELOG.md</code>","text":"<p>I used to be pretty lax with CHANGELOGs, but after reading keep a changelog, I realized that it's a pretty important element of an open-source software project.</p> <p>Since I started including them, I've found that they are extremely useful for other people who want to learn about how your project has evolved over time. More importantly, it helps identify when significant changes (like dropping version support) came to be. Now, when I'm reading up on a project without a changelog, I get pretty grumpy.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#structure","title":"Structure","text":"<p>This is so subjective. I've also been through many iterations of different structures with pretty strong opinions on each one that I adopted. I used to be pretty adamant about using a \"flat layout\", but these days I've adopted the src layout. In the end, the deciding factor was that uv prefers the \"src layout\", and I've been using <code>uv</code> a lot lately.</p> <p>So, my basic project structure looks like:</p> <pre><code>space-monkey/\n\u2514\u2500\u2500 .github/\n    \u251c\u2500\u2500 workflows/\n    \u2502   \u251c\u2500\u2500 deploy.yml\n    \u2502   \u251c\u2500\u2500 docs.yml\n    \u2502   \u2514\u2500\u2500 main.yml\n    \u251c\u2500\u2500 docs/\n    \u2502   \u251c\u2500\u2500 source/\n    \u2502   \u2502   \u251c\u2500\u2500 features.md\n    \u2502   \u2502   \u251c\u2500\u2500 index.md\n    \u2502   \u2502   \u251c\u2500\u2500 quickstart.md\n    \u2502   \u2502   \u2514\u2500\u2500 reference.md\n    \u2502   \u2514\u2500\u2500 mkdocs.yaml\n    \u251c\u2500\u2500 src/\n    \u2502   \u2514\u2500\u2500 space_monkey/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 main.py\n    \u2502       \u2514\u2500\u2500 py.typed\n    \u2514\u2500\u2500 tests/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u2514\u2500\u2500 test_main.py\n</code></pre> <p>Note that this structure includes a <code>tests</code> directory that includes a full suite of unit tests and integration tests when they are appropriate. I use pytest to run my tests--it's really just the best option out there.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#documentation","title":"Documentation","text":"<p>As I mentioned in the README.md section, I usually put the bulk of my documentation in a static site hosted on GitHub pages and generated by mkdocs-material. It's really easy, and it results in a nice docs site that is searchable, themed, and familiar.</p> <p>In fact, this blog itself is a GitHub Pages site built with mkdocs-material!</p> <p>At a minimum, I like my docs to include an overview of the project, a good description of usage, a full explanation of the features, examples, and a reference section that is built from the docstrings in the project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#ergonomics","title":"Ergonomics","text":"<p>Beyond the baseline requirements, I like to add some elements to my projects that make them nice to work on. I love good tools that are pleasure to use, so I'm always looking for cool things I can bring into my projects to make them more fun to work on. There are 3 core elements to all my projects that improve the ergonomics. These include:</p> <ol> <li>A <code>Makefile</code></li> <li><code>uv</code> support</li> <li>GitHub actions</li> </ol> <p>I'll explain a little about each one.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#makefile","title":"<code>Makefile</code>","text":"<p>There are a lot of alternatives to <code>make</code> these days. So, why do I chose something so old? It certainly isn't the syntax. Instead, it's because <code>make</code> comes pre-installed in most unix systems. So, it's nice to use something that doesn't require an installation. That might not be a great reason, but I have a good <code>Makefile</code> structure now, so I'm sticking with it for the time being.</p> <p>My <code>Makefile</code> usually has these targets:</p> <ul> <li>test:       run the test suite</li> <li>lint:       run code linters</li> <li>types:      run type-checkers</li> <li>qa:         run all three of <code>test</code>, <code>lint</code>, and <code>types</code></li> <li>format:     run a code formatter</li> <li>docs:       build the docs</li> <li>docs-serve: build the docs and run them in a local, auto-refreshing server</li> <li>clean:      clean up all the cruft including cache files and build artifacts</li> <li>help:       show available <code>make</code> targets</li> </ul> <p>It's really convenient to just run <code>make qa</code> and see all the quality checks being applied.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#uv","title":"<code>uv</code>","text":"<p>Like I said before, I've been using <code>uv</code> these days for all my new projects. It's really fast and has most of the features I want in project management software for Python. Beyond that, though, it has massive adoption in the Python community. I really believe this will become the standard for Python projects in the coming years.</p> <p>I used to be a die-hard supporter of <code>poetry</code>. I still like the project, but I've found that <code>uv</code> is just nicer to use.</p> <p>As a bonus, <code>uv</code> comes with built-in Python version management with a better API and faster execution times than pyenv (which I used to use).</p> <p>So, all my projects these days are configured for <code>uv</code> to manage them. Since <code>uv</code> doesn't have a build backend yet, I fallback on using hatchling in my <code>pyproject.toml</code></p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#github-actions","title":"GitHub Actions","text":"<p>It's really nice to take advantage of CI even in small projects. Having automated quality checks and deployments built right into a project really take it to the next level. I usually set up three GitHub actions for my projects:</p> <ul> <li>run qa checks on any pushed branch</li> <li>build &amp; deploy docs on any merge to <code>main</code></li> <li>deploy a new version of the package on any tag matching a semver format</li> </ul> <p>Many of the projects I make end up getting deployed on PyPI, so the third of these actions is really nice to have. If the project won't be deployed as a package, I'll leave off the third one.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#processes","title":"Processes","text":"<p>This might be the most boring of these boring parts. In general, when I'm starting a new project, I like to put it up on GitHub right away. This allows me to work on the project from anywhere. Since I work from a rented office a few miles down the road, it's nice to be able to just pull down the latest changes from GitHub directly instead of using <code>scp</code> or <code>rsync</code> to move the files around. So, to get a new project set up on GitHub, I do these steps:</p> <ol> <li>Initialize the git repo</li> <li>Host it on GitHub</li> <li>Set up a GitHub Page</li> </ol> <p>None of these are interesting, but they are important steps, and (before the new project template) they were all done manually.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#git-init","title":"<code>git init</code>","text":"<p>That's the main command at the heart of setting up a new git repo locally. However, there's a few other things I like to do. I like my first commit to have nothing in it but a <code>README.md</code> that contains nothing but the title of the project. It's not really a fun thing to try to rebase the first commit in a git repo. So, having it be almost completely empty means that I can use it as an immutable base for all future commits.</p> <pre><code>git init\ngit add REAME.md\ngit commit -m \"Initial Commit\"\n</code></pre> <p>Once that's done, my next commit will contain all of the contents (minus cruft that <code>make clean</code> will remove) of the project. Usually, I won't finalize this commit until I have the MVP working. That often means making several temporary commits that all get squashed down into this one before I push it anywhere.</p> <pre><code>git add .\ngit commit -m \"feat: Bootstrapped the space-mokey project\"\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#to-github","title":"To GitHub","text":"<p>This is just a matter of going to GitHub and clicking the <code>+</code> button to create a new repository:</p> <p></p> <p>Screenshot of the plus button</p> <p>Then, there's the fun of setting the upstream git repository hosted on GitHub as the origin for the local git repository. Once that's done, it's just a matter of pushing <code>main</code> to origin.</p> <pre><code>git remote add origin git@github.com:dusktreader/space-monkey.git\ngit push origin main\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#github-pages","title":"GitHub Pages","text":"<p>Finally, to publish the docs on GitHub pages, you have to change a few settings. First, you need to go to the <code>settings</code> for your project and find the <code>actions</code> section on the left. Once there, scroll down and find \"Workflow Permissions\". Then, change it to enable \"Read and write permissions\".</p> <p></p> <p>Screenshot of actions settings</p> <p>Easier method</p> <p>I discovered a little later that it's not necessary to set the Read and write permissions manually if you set the permissions inside of the GitHub action to build the docs like this:</p> <pre><code>jobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n      pages: write\n</code></pre> <p>Once that's done, while you are still in settings, the deployment branch needs to be selected. This is found under the \"Pages\" section on the left. Then, the <code>gh-pages</code> branch and root folder needs to be selected. Any branch can be used for deployment, but the actions-gh-pages action that I use builds the docs in the <code>gh-pages</code> branch by default.</p> <p></p> <p>Screenshot of branch and folder selection</p> <p>Note that you can't actually select the <code>gh-pages</code> branch unless it has been created already. The <code>actions-gh-pages</code> action will do this automatically, but it must have completed successfully first. If it failed after that initial push, it's probably because the \"Read and write permissions\" weren't enabled yet. It's easy to just re-run the action in that case to build the docs.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#summing-up-the-boring-stuff","title":"Summing up the boring stuff","text":"<p>So, now I've described all the setup and scaffolding that I like to include in a Python project. Given all that is here, you can see why it takes a while to get everything into place for a new project. This really is the boring part of a new project. Nothing I've talked about yet is that creative or interesting.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#automating-the-boring-stuff","title":"Automating the boring stuff","text":"<p>There's a seminal book about Python called Automate the Boring Stuff with Python by Al Sweigart that operates on the premise that Python is a great language for automating boring tasks. While the template project that I built doesn't itself use much Python, the sentiment is a good one. The whole point of the template project and this article is how automation takes away the drudgery of setting up a new Python project. So, let's get into the fun part!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#template-engine-selection","title":"Template Engine Selection","text":"<p>There are a few project template engines out there including the most famous: cookiecutter. I've used <code>cookiecutter</code> before, and it's...fine. However, I've also found some sharp edges while using it.</p> <p>Overall, I just wanted to try something new, so I reached for copier.</p> <p><code>copier</code> has a lot of cool features that are unique to it. Really, though, I'm only interested in creating a template to automate setting up a new Python project. After reading over the docs for a bit, I felt good about my selection and got to work.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#template-variables","title":"Template variables","text":"<p>After examining a few of my old project, I identified 5 elements that are essential to a new Python project. With these 5 settings, I can bootstrap a new project that is customized and ready to go. These 5 elements can be defined by template variables that <code>copier</code> learns by asking you interactive questions to get the values. The 5 elements are:</p> <ol> <li><code>project_name</code></li> <li><code>project_summary</code></li> <li><code>module_name</code></li> <li><code>python_versions</code></li> <li><code>default_python_version</code></li> </ol> <p>I'll explain each one in more detail.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#project_name","title":"<code>project_name</code>","text":"<p>This will be the name of the project, the name of the folder that holds it, and the package name on PyPI. In our case study, this is <code>space-monkey</code>.</p> <p>I like my <code>project_name</code> to use kebab case for longer names, and I like the to name to always be lowercase.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#project_summary","title":"<code>project_summary</code>","text":"<p>This is a short description of what the project is and does. It's usually just a sentence long. I use this at the top of the <code>README.md</code>, in the docs, in the <code>pyproject.toml</code>, and on the GitHub page for the project. For <code>space-monkey</code>, let's use \"It's a trial run\" as the <code>project_summary</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#module_name","title":"<code>module_name</code>","text":"<p>This is the name of the Python module from which any source code is imported. Often, this is the same as the <code>project_name</code>. However, if the <code>project_name</code> has dashes in it, a Python module can't include those. Thus it should use snake case. For <code>space-monkey</code>, the <code>module_name</code> becomes <code>space_monkey</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#python_versions","title":"<code>python_versions</code>","text":"<p>These are the versions of Python that the project should support. This should be a consecutive list of Python versions that the project's source code will work in. The full list is used in the GitHub action that runs tests and type-checks on all branches. The range of versions is used in <code>pyproject.toml</code> to identify compatible Python versions for the project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#default_python_version","title":"<code>default_python_version</code>","text":"<p>This should identify the Python version that is used by default in the project. For example, the project might support all the way back to Python 3.9, but I prefer to work in Python 3.13. This is the version that will get set in the <code>.python-version</code> so that <code>uv</code> runs everything in Python 3.13 for <code>space-monkey</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#copieryaml","title":"<code>copier.yaml</code>","text":"<p>Once I knew the key elements for the <code>copier</code> project, I could constrain the questions in the <code>copier</code> configuration file named <code>copier.yaml</code>. This file sits at the root of the template project and defines everything <code>copier</code> needs to know in order to generate a new project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#basic-questions","title":"Basic questions","text":"<p>First, I needed to define the basic questions. So, I started pretty simply:</p> <pre><code>project_name:\n  type: str\n  help: What is the name of the project?\n\nproject_summary:\n  type: str\n  help: Provide a short summary of the project.\n\nmodule_name:\n  type: str\n  help: What is the Python module name?\n</code></pre> <p>This was very straightforward. <code>copier</code> asks the question described by the <code>help</code> field and stores the answer provided by the user in the template variable.</p> <p>However, I realized there was an issue here. What if the user (me) enters the empty string as the <code>project_name</code>? Since this will be used as the name of the folder to hold the project, it obviously must not be the empty string. Additionally, as I said earlier, I want the <code>project_name</code> to be in \"kebab\" case and only include lowercase characters.</p> <p>To make this possible, I used a <code>copier</code> validator. Fortunately, the <code>copier.yaml</code> file can include some <code>jinja</code> in it to make things more dynamic. After setting up my validator, the <code>project_name</code> definition ended up looking like this:</p> <pre><code>project_name:\n  type: str\n  help: What is the name of the project?\n  validator: |\n    {% if project_name|length &lt; 4 or project_name|length &gt; 40 %}\n    project_name must be between 4 and 40 characters\n    {% endif %}\n    {% if not (project_name | regex_search('^[a-z][a-z0-9\\-]+$')) %}\n    project_name must start with a letter, followed one or more letters, digits or dashes (all lowercase).\n    {% endif %}\n</code></pre> <p>Notice that the <code>validator</code> item in the yaml is defined as a multiline string using the <code>|</code> operator. This is because all <code>jinja</code> directives have to be in strings so that the file itself is still valid YAML. Read more in the <code>copier</code> docs about these constraints.</p> <p>Next, I wanted to also constrain the <code>project_summary</code>. I also wanted it to have a default value that was equivalent to the <code>project_name</code> only in \"snake_case\" instead of \"kebab-case\". I ended up writing this definition as:</p> <pre><code>module_name:\n  type: str\n  help: What is the Python module name?\n  default: \"{{ project_name.replace('-', '_') }}\"\n  validator: |\n    {% if module_name|length &lt; 4 or module_name|length &gt; 40 %}\n    module_name must be between 4 and 40 characters\n    {% endif %}\n    {% if not (module_name | regex_search('^[a-z][a-z0-9_]+$')) %}\n    module_name must start with a letter, followed one or more letters, digits or underscores (all lowercase).\n    {% endif %}\n</code></pre> <p>I decided that I didn't care if the <code>project_summary</code> was empty, so I didn't add a validator for it.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#choices","title":"Choices","text":"<p>For the <code>python_versions</code> question, I needed to define a set of choices that the user can choose from to limit the answer for the supported versions of Python. This keeps the user from selecting a version of python that doesn't exist or isn't supported any more:</p> <pre><code>python_versions:\n  type: str\n  default:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n  multiselect: true\n  choices:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n</code></pre> <p>This works by limiting the choices to Python 3.9 through 3.13. Because I enabled <code>multiselect</code> the user can select more than one Python version to include. Additionally, I set the default to all available versions to just make things easier.</p> <p>If you have a discerning eye, you might notice a problem here. I will be using these Python versions in <code>pyproject.toml</code> to identify what versions my project should work with. However (according to it's specification) <code>pyproject.toml</code> can only specify a range of versions if more than one must be supported. Thus, I could have an issue if the selected versions were not consecutive. Choosing 3.10, 3.12, 3.13 while leaving out 3.11 would be problematic. To address this, I figured out a validator that can handle this constraint:</p> <pre><code>python_versions:\n  type: str\n  help: What Python versions will be supported?\n  default:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n  multiselect: true\n  choices:\n    - \"3.9\"\n    - \"3.10\"\n    - \"3.11\"\n    - \"3.12\"\n    - \"3.13\"\n  validator: |\n    {% set all_ver = [\"3.9\", \"3.10\", \"3.11\", \"3.12\", \"3.13\"] %}\n    {% if all_ver.index(python_versions[-1]) - all_ver.index(python_versions[0]) + 1 != python_versions|length %}\n    python_versions must be a consecutive list of versions\n    {% endif %}\n</code></pre> <p>Next, I needed to create a question for the <code>default_python_version</code>. Right away, it was clear that this had to be constrained to be one of the values chosen for <code>python_versions</code>. Additionally, I wanted this to default to the latest supported Python version from the selected list. To make this happen, I made <code>default_python_version</code> quite dynamic:</p> <pre><code>default_python_version:\n  type: str\n  help: What is the default Python version to use?\n  default: \"{{python_versions[-1]}}\"\n  choices: |\n    {% for ver in python_versions %}\n    - \"{{ver}}\"\n    {% endfor %}\n</code></pre> <p>With that, I'd finished defining the questions needed to define the 5 critical template variables needed for a new project.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#building-out-the-project-structure","title":"Building out the project structure","text":"<p><code>copier</code> uses Jinja to inject the values for the template variables it gathers from the questionnaire into not only the contents of the project template files, but into their filenames as well. To inject into files, the files must be of type <code>.jinja</code>.</p> <p>Remember my directory structure that I laid out before? Well, now I need to convert some of those files into Jinja templates so that I can get the correct values into them. To fast-forward a bit, the file structure now looks like this:</p> <pre><code>{{project_name}}/\n\u2514\u2500\u2500 .github/\n    \u251c\u2500\u2500 workflows/\n    \u2502   \u251c\u2500\u2500 deploy.yml.jinja\n    \u2502   \u251c\u2500\u2500 docs.yml.jinja\n    \u2502   \u2514\u2500\u2500 main.yml.jinja\n    \u251c\u2500\u2500 docs/\n    \u2502   \u251c\u2500\u2500 source/\n    \u2502   \u2502   \u251c\u2500\u2500 features.md\n    \u2502   \u2502   \u251c\u2500\u2500 index.md.jinja\n    \u2502   \u2502   \u251c\u2500\u2500 quickstart.md.jinja\n    \u2502   \u2502   \u2514\u2500\u2500 reference.md.jinja\n    \u2502   \u2514\u2500\u2500 mkdocs.yaml.jinja\n    \u251c\u2500\u2500 src/\n    \u2502   \u2514\u2500\u2500 {{module_name}}/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u251c\u2500\u2500 main.py\n    \u2502       \u2514\u2500\u2500 py.typed\n    \u2514\u2500\u2500 tests/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 conftest.py\n        \u2514\u2500\u2500 test_main.py.jinja\n</code></pre> <p>Every file that has a <code>.jinja</code> extension needs to have one of the 5 values injected into it. Additionally, the root folder should use the selected <code>project_name</code>, and the module in the <code>src</code> directory should use the <code>module_name</code>.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#making-a-templated-file","title":"Making a templated file","text":"<p>To show how Jinja template variable injections work, check out the internals of one of the templated files:</p> <pre><code>name: QA on push\nrun-name: qa-checks\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version:\n          {% for ver in python_versions -%}\n          - '{{ ver }}'\n          {% endfor %}\n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v4\n\n    - name: Install uv\n      uses: astral-sh/setup-uv@v5\n\n    - name: Install python\n      run:  uv python install {{ \"${{ matrix.python-version }}\" }}\n\n    - name: Check Quality\n      run: make qa\n\n    - name: Upload coverage reports to Codecov\n      uses: codecov/codecov-action@v5\n      with:\n        files: ./.coverage.xml\n        token: {{ \"${{ secrets.CODECOV_TOKEN }}\" }}\n      if: {{ \"${{ !cancelled() }}\" }}\n\n    - name: Upload test results to Codecov\n      uses: codecov/test-results-action@v1\n      with:\n        token: {{ \"${{ secrets.CODECOV_TOKEN }}\" }}\n        files: ./.junit.xml\n      if: {{ \"${{ !cancelled() }}\" }}\n</code></pre> <p>There's a few interesting things to take note of here. First, you can see that we are using the <code>python_versions</code> from before to tell the GitHub action the matrix of versions to use in the test runs. It will create a separate run of the test job for every version that was selected before.</p> <p>Note down in the \"Install python\" step, there's something wild going on. In a vanilla GitHub action YAML file, this section would look like:</p> <pre><code>    - name: Install python\n      run:  uv python install ${{ matrix.python-version }}\n</code></pre> <p>However, because it's a Jinja file now, double curly braces mean something special. Consequently, we need to escape the existing double curly braces. The Jinja way to do this is to make the original double curly expression a string and surround it again with double curlies. It's ugly, but it gets the job done:</p> <pre><code>    - name: Install python\n      run:  uv python install {{ \"${{ matrix.python-version }}\" }}\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#creating-a-template-folder","title":"Creating a template folder","text":"<p>By default, <code>copier</code> expects the templated project files to live in the same directory as <code>copier.yaml</code>. However, because I have lots of other files that I want as a part of my template project, that wasn't going to work for me. Fortunately, <code>copier</code> allows you to identify a different subdirectory that holds your template. So, I packaged up the whole project structure in a <code>template</code> subdirectory and updated my <code>copier.yaml</code> file to include a subdirectory section like this:</p> <pre><code>_subdirectory: template\n</code></pre>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#generating-a-new-project","title":"Generating a new project","text":"<p>Now that everything is in place, it was time to generate a new project. So, I kicked off copier with the following command:</p> <pre><code>uv run copier copy . ..\n</code></pre> <p>Basically, I was telling <code>copier</code> to create the new project using the template defined in the current directory. Additionally, I wanted the new project to be created in the parent of my template project. Thus, the new project live in a sibling folder of my template project's root.</p> <p>Next, I ran through the questionnaire as follows:</p> <pre><code>\ud83c\udfa4 What is the name of the project?\n   space-monkey\n\ud83c\udfa4 Provide a short summary of the project.\n   It's a trial run\n\ud83c\udfa4 What is the Python module name?\n   space_monkey\n\ud83c\udfa4 What Python versions will be supported?\n   done (3 selections)\n\ud83c\udfa4 What is the default Python version to use?\n   3.13\n\nCopying from template version 0.0.0.post3.dev0+c69bc53\n    create  space-monkey\n    create  space-monkey/.python-version\n    create  space-monkey/src\n    create  space-monkey/src/space_monkey\n    create  space-monkey/src/space_monkey/main.py\n    create  space-monkey/src/space_monkey/__init__.py\n    create  space-monkey/src/space_monkey/py.typed\n    create  space-monkey/.gitignore\n    create  space-monkey/tests\n    create  space-monkey/tests/test_main.py\n    create  space-monkey/tests/conftest.py\n    create  space-monkey/tests/__init__.py\n    create  space-monkey/Makefile\n    create  space-monkey/CHANGELOG.md\n    create  space-monkey/docs\n    create  space-monkey/docs/mkdocs.yaml\n    create  space-monkey/docs/source\n    create  space-monkey/docs/source/features.md\n    create  space-monkey/docs/source/index.md\n    create  space-monkey/docs/source/reference.md\n    create  space-monkey/docs/source/quickstart.md\n    create  space-monkey/.github\n    create  space-monkey/.github/workflows\n    create  space-monkey/.github/workflows/deploy.yml\n    create  space-monkey/.github/workflows/main.yml\n    create  space-monkey/.github/workflows/docs.yml\n    create  space-monkey/README.md\n    create  space-monkey/LICENSE.md\n    create  space-monkey/pyproject.toml\n</code></pre> <p>GREAT! It worked! Now I have a new Python project that includes all the scaffolding I like to have, and it's ready to build on.</p> <p>However, this doesn't fix the pain of having to set up git and GitHub. I still would have to do those manual steps to complete the process.</p> <p>So, I decided to investigate if I those steps could be automated as well.</p> <p>SPOILER ALERT</p> <p>They could be automated!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#automating-github-deployment-with-tasks","title":"Automating GitHub Deployment with Tasks","text":"<p>With the Python project setup all automated, I needed to find out what I could do about automating the manual steps that are needed to roll the project out to GitHub. Remember that in the Processes section, I described 3 manual steps that I needed to perform in order to get a new project up on GitHub:</p> <ol> <li>Initialize the git repo</li> <li>Host it on GitHub</li> <li>Set up a GitHub Page</li> </ol> <p>All these steps happen after the project is functional in its MVP form and ready to make public. So, I dug deeper into <code>copier</code> to see what it offered for automating steps like this.</p> <p>It turns out that <code>copier</code> supports tasks that run after the project is generated. This fit my needs perfectly! However, in reading the docs on <code>_tasks</code>, something pretty important jumped out:</p> <p>Copier templates can use dangerous features that allow arbitrary code execution:</p> <ul> <li>Jinja extensions</li> <li>Migrations</li> <li>Tasks</li> </ul> <p>Therefore, these features are disabled by default and Copier will raise an error (and exit from the CLI with code 4) when they are found in a template. In this case, please verify that no malicious code gets executed by any of the used features. When you're sufficiently confident or willing to take the risk, set unsafe=True or pass the CLI switch --UNSAFE or --trust.</p> <p>This sounds pretty scary, BUT! I am building this project template for my own use. I think I can trust executable code that I wrote myself--though sometimes I wonder! All I needed to add to take advantage of the <code>_tasks</code> directive was a <code>--trust</code> flag in the <code>copier</code> command:</p> <pre><code>uv run copier copy --trust . ..\n</code></pre> <p>With that handled, I worked on my tasks next.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-1-make-sure-the-project-works","title":"Task 1: Make sure the project works","text":"<p>I decided that it would be really nice to make sure that the project is actually working as expected before I pulbished it on GitHub. Since I already added commands for linting, unit tests, and type-checks to my <code>Makefile</code>, I could verify that the basics in the project work with a single command: <code>make qa</code>. I added this to the <code>_tasks</code> section with a single command:</p> <pre><code>_tasks:\n  - working_directory: \"{{ project_name }}\"\n    command: \"make qa\"\n</code></pre> <p>Notice that this command sets the working directory to the <code>project_name</code>. That meant that this command is actually executed in the generated project. I don't need to make the directory path relative to the path where I run the command because I have already directed <code>copier</code> to execute the template in the parent directory of the template project (remember the <code>..</code>). Thus, the command will be executed exactly where I wanted. I took the new task for a spin:</p> <pre><code>\ud83c\udfa4 What is the name of the project?\n   space-monkey\n\ud83c\udfa4 Provide a short summary of the project.\n   It's a trial run\n\ud83c\udfa4 What is the Python module name?\n   space_monkey\n\ud83c\udfa4 What Python versions will be supported?\n   done (3 selections)\n\ud83c\udfa4 What is the default Python version to use?\n   3.13\n\nCopying from template version 0.0.0.post3.dev0+4a481f3\n...\n\n &gt; Running task 1 of 1: make qa\nmake[1]: Entering directory '/home/dusktreader/git-repos/personal/space-monkey'\nuv run pytest\n...\ntests/test_main.py .                                                                                                                                                                                         [100%]\n...\nuv run ruff check src/space_monkey tests\nAll checks passed!\nuv run mypy src/space_monkey tests --pretty\nuv run basedpyright src/space_monkey tests\nSuccess: no issues found in 5 source files\n0 errors, 0 warnings, 0 notes\necho \"All quality checks pass!\"\nAll quality checks pass!\nmake[1]: Leaving directory '/home/dusktreader/git-repos/personal/space-monkey'\n</code></pre> <p>I omitted some output (...) here to make save some space. Still, you can see that it ran my QA checks after generating the project and all of the checks passed. Great! Now I'm confident that the generated project had a baseline of functinoality.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-2-6-initialize-the-git-repository","title":"Task 2-6: Initialize the git repository","text":"<p>The next series of tasks covered the manual steps I described to initialize the git repository. These steps are really easy to define in tasks:</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: \"git init .\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git add README.md\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git commit -m 'Initial Commit'\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git add .\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git commit -m 'feat: Bootstrapped the {{ project_name }} project'\"\n</code></pre> <p>There's not much to comment on here other than the nicety of including the templated <code>project_name</code> value in the first git commit message. The output from this steps (with some stuff removed) looked like this:</p> <pre><code> &gt; Running task 2 of 6: git init .\nInitialized empty Git repository in /home/dusktreader/git-repos/personal/space-monkey/.git/\n &gt; Running task 3 of 6: git add README.md\n &gt; Running task 4 of 6: git commit -m 'Initial Commit'\n[main (root-commit) 4106d13] Initial Commit\n 1 file changed, 29 insertions(+)\n create mode 100644 README.md\n &gt; Running task 5 of 6: git add .\n &gt; Running task 6 of 6: git commit -m 'feat: Bootstrapped the space-monke`y project'\n[main d830fcb] feat: Bootstrapped the space-monkey project\n 21 files changed, 1339 insertions(+)\n ...\n</code></pre> <p>Now, I was really getting somewhere on automating boring steps!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-7-8-create-the-project-on-github","title":"Task 7 &amp; 8: Create the project on GitHub","text":"<p>For the next two steps, I needed to be able to interact with GitHub from the command-line. Fortunately, GitHub had a very powerful CLI available that can do it all! I just had to install it. The installation wasn't super clean, but after following the instructions in the docs, I had GitHub CLI up and running. Next, I needed to login through the CLI to my GitHub account:</p> <pre><code>gh auth login\n</code></pre> <p>After following the steps to complete device authorization flow, I was fully logged in.</p> <p>Next, I defined the steps to create the project on GitHub and push my <code>main</code> branch to the new origin.</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: \"gh repo create --description=\\\"{{ project_summary }}\\\" --source=. --public {{ project_name }}\"\n  - working_directory: \"{{ project_name }}\"\n    command: \"git push -u origin main\"\n</code></pre> <p>The <code>create</code> command is really straightforward, and it's nice that I could use the <code>project_summary</code> as the project description on GitHub. Executing the tasks looked like this:</p> <pre><code> &gt; Running task 7 of 8: gh repo create --description=\"It's a trial run\" --source=. --public space-monkey\n2025/04/06 11:28:35.534717 cmd_run.go:1285: WARNING: cannot start document portal: dial unix /run/user/1000/bus: connect: connection refused\n\u2713 Created repository dusktreader/space-monkey on GitHub\n\u2713 Added remote git@github.com:dusktreader/space-monkey.git\n &gt; Running task 8 of 8: git push -u origin main\nEnumerating objects: 30, done.\nCounting objects: 100% (30/30), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (23/23), done.\nWriting objects: 100% (30/30), 30.07 KiB | 2.15 MiB/s, done.\nTotal 30 (delta 1), reused 0 (delta 0), pack-reused 0 (from 0)\nremote: Resolving deltas: 100% (1/1), done.\nTo github.com:dusktreader/space-monkey.git\n * [new branch]      main -&gt; main\nbranch 'main' set up to track 'origin/main'.\n</code></pre> <p>When I went to check the repo on GitHub, I could see that it was all set up!</p> <p></p> <p>space-monkey now on GitHub!</p> <p></p> <p>about section has the summary</p> <p></p> <p>space-monkey README</p> <p>And, when I checked the Actions, I verified that the docs build succeeded as well:</p> <p></p> <p>space-monkey build-docs action</p> <p>However, the GitHub Pages site for the docs was not built yet, because it wasn't configured as I described in the GitHub Pages section. So, I needed a few more actions to make that happen.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-9-11-publish-the-github-page","title":"Task 9-11: Publish the GitHub Page","text":"<p>Figuring out how to configure my repo to publish the GitHub Pages site took some digging. I found that this functionality isn't actually built in to the GitHub CLI directly. However, the CLI does allow you to call any API endpoint provided by GitHub! Once I learned that, it was only a matter of finding the endpoint and learning how to call it. The complete CLI command looked like this (I've broken it up into several lines to make it easier to read):</p> <pre><code>gh api \\\n  --method=POST \\\n  -H \"Accept: application/vnd.github+json\" \\\n  \"/repos/dusktreader/so-dumb/pages\" \\\n  -f \"source[branch]=gh-pages\" \\\n  -f \"source[path]=/\" \\\n  -f \"build_type=legacy\"\n</code></pre> <p>It worked, but I quickly realized there was a problem. This command will only work after the GitHub action to build the docs is completed. That action creates a new branch in the repo called <code>gh-pages</code> where the built docs are staged. If you try to run the GitHub API command before that branch exists, it will fail.</p> <p>So, I needed to make sure that the <code>build-docs</code> action completed before I ran the command. That took even more digging, but I was able to figure out how to do it in two steps:</p> <ol> <li>Wait for the <code>build-docs</code> action to start</li> <li>Once it's started, wait for it to complete</li> </ol> <p>After refining those steps into tasks, my YAML looked like this:</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"build-docs\")')\" ]; do\n        echo \"Waiting for docs build action to start\" &amp;&amp; sleep 1;\n      done\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      gh run list --json databaseId,name\n      | jq '.[] | select(.name == \"build-docs\")'\n      | jq '.databaseId'\n      | xargs gh run watch --exit-status\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      gh api\n      --silent\n      --method=POST\n      -H \"Accept: application/vnd.github+json\"\n      \"/repos/dusktreader/{{ project_name }}/pages\"\n      -f \"source[branch]=gh-pages\"\n      -f \"source[path]=/\"\n      -f \"build_type=legacy\"\n</code></pre> <p>Once I had the tasks in place, running it produced this output:</p> <pre><code> &gt; Running task 9 of 10: while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"build-docs\")')\" ]; do\n  echo \"Waiting for docs build action to start\" &amp;&amp; sleep 1;\ndone\n\nWaiting for docs build action to start\nWaiting for docs build action to start\nWaiting for docs build action to start\n &gt; Running task 10 of 10: gh run list --json databaseId,name | jq '.[] | select(.name == \"build-docs\")' | jq '.databaseId' | xargs gh run watch --exit-status\n\nRefreshing run status every 3 seconds. Press Ctrl+C to quit.\n\n\u2713 main build-docs \u00b7 14295750274\nTriggered via push less than a minute ago\n\nJOBS\n\u2713 build in 12s (ID 40062668601)\n  \u2713 Set up job\n  \u2713 Checkout repository\n  \u2713 Install uv\n  \u2713 Set up Python\n  \u2713 Build Documentation\n  \u2713 Deploy documentation\n  \u2713 Post Install uv\n  \u2713 Post Checkout repository\n  \u2713 Complete job\n\n\u2713 Run build-docs (14295750274) completed with 'success'\n &gt; Running task 11 of 11: gh api --method=POST -H \"Accept: application/vnd.github+json\" \"/repos/dusktreader/space-monkey/pages\" -f \"source[branch]=gh-pages\" -f \"source[path]=/\" -f \"build_type=legacy\"\n</code></pre> <p>That's it! My project is now available on GitHub and the docs page is also built...well, not yet actually. The page wasn't deployed yet because the final GitHub action named \"pages build and deployment\" had to finish first. So, I decided to add one last finishing touch.</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#task-12-14-wrapping-it-up","title":"Task 12-14: Wrapping it up","text":"<p>For this final step, I just needed to add another task to wait for the page deployment to complete. I also wanted to add a message at the end confirming that the tasks completed successfully and include a URL to the new GitHub repo so that I could open it with a click. The final tasks looked like this:</p> <pre><code>  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"pages build and deployment\")')\" ]; do\n        echo \"Waiting for page deploy action to start\" &amp;&amp; sleep 1;\n      done\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      gh run list --json databaseId,name\n      | jq '.[] | select(.name == \"pages build and deployment\")'\n      | jq '.databaseId'\n      | xargs gh run watch --exit-status\n  - working_directory: \"{{ project_name }}\"\n    command: &gt;\n      echo \"Finished bootstrapping {{ project_name }}!\" &amp;&amp;\n      echo \"Check it out at https://github.com/dusktreader/{{ project_name }}\"\n</code></pre> <p>This produced output from <code>copier</code> that looked like this:</p> <pre><code> &gt; Running task 12 of 14: while [ -z \"$(gh run list --json databaseId,name | jq '.[] | select(.name == \"pages build and deployment\")')\" ]; do\n  echo \"Waiting for page deploy action to start\" &amp;&amp; sleep 1;\ndone\n\nWaiting for docs build action to start\nWaiting for docs build action to start\nWaiting for docs build action to start\n &gt; Running task 13 of 14: gh run list --json databaseId,name | jq '.[] | select(.name == \"pages build and deployment\")' | jq '.databaseId' | xargs gh run watch --exit-status\nRefreshing run status every 3 seconds. Press Ctrl+C to quit.\n\n\u2713 gh-pages pages build and deployment \u00b7 14295984823\nTriggered via dynamic less than a minute ago\n\nJOBS\n\u2713 build in 7s (ID 40063197951)\n  \u2713 Set up job\n  \u2713 Checkout\n  \u2713 Upload artifact\n  \u2713 Post Checkout\n  \u2713 Complete job\n\u2713 report-build-status in 3s (ID 40063199711)\n  \u2713 Set up job\n  \u2713 Report Build Status\n  \u2713 Complete job\n\u2713 deploy in 10s (ID 40063199712)\n  \u2713 Set up job\n  \u2713 Deploy to GitHub Pages\n  \u2713 Complete job\n\n\u2713 Run pages build and deployment (14295984823) completed with 'success'\n &gt; Running task 14 of 14: echo \"Finished bootstrapping space-monkey!\" &amp;&amp; echo \"Check it out at https://github.com/dusktreader/space-monkey\"\n\nFinished bootstrapping space-monkey!\nCheck it out at https://github.com/dusktreader/space-monkey\n</code></pre> <p>Excellent! I clicked on the URL at the end and checked out the docs:</p> <p></p> <p>space-monkey docs page!</p> <p>There they were! After all that work, my template project was ready to stamp out new Python projects!</p>","tags":["Python","copier","uv"]},{"location":"2025/04/06/bootstrapping-python-projects-with-copier/#conclusion","title":"Conclusion","text":"<p>My template project was pretty much complete at this point. It could produce a mostly empty Python project, but all of the scaffolding was complete and the project was published on GitHub.</p> <p>Running the whole process took just over a minute:</p> <pre><code>real    1m15.743s\nuser    0m8.678s\nsys     0m2.462s\n</code></pre> <p>I am really happy with how this turned out. Still, I don't think the template project is 100% done yet. In particular, there are a few things I'd like to improve in it:</p> <ol> <li>Cleaning up some of the output so it's not so noisy</li> <li>Encapsulating the GitHub CLI commands in scripts to make the YAML more concise</li> <li>Figuring out how to seed the list of python versions with a reusable variable</li> <li>Making the GitHub user account a question so other people can use the template more easily</li> <li>Adding some optional components so I can bootstrap CLI apps vs API apps</li> <li>Configuring GitHub to set the URL of the docs page in the \"About\" section</li> </ol> <p>This is a solid start, though, and definitely a tool that I will find really useful for future Python projects.</p> <p>If you are interested in the nitty-gritty details of the template, please check out my dusky-clone project on GitHub. Comments, issues, and PRs are always welcome.</p> <p>Before I take off, I'd like to thank the maintiners of <code>copier</code> for creating such a great template builder. It really was a joy to work with!</p> <p>So, what do you think? Let me know below in the comments.</p> <p>Thanks for reading!</p>","tags":["Python","copier","uv"]},{"location":"archive/2025/","title":"2025","text":""},{"location":"category/dev/","title":"dev","text":""}]}